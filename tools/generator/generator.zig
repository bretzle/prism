const std = @import("std");

const tab = "    ";
const dtab = tab ++ tab;
const allocator = std.heap.smp_allocator;

const insert_magic =
    \\// THIS FILE IS AUTOGENERATED BEYOND THIS POINT! DO NOT EDIT!
    \\// ----------------------------------------------------------
    \\
;

const mapping = [_]struct {
    source: []const u8,
    target: []const u8,
}{
    .{ .source = "dxgi.registry", .target = "deps/w32/dxgi.zig" },
    .{ .source = "d3d12.registry", .target = "deps/w32/d3d12.zig" },
};

pub fn main() !void {
    const generator_dir = try std.fs.cwd().openDir("tools/generator", .{});

    for (mapping) |entry| {
        const registry = try generator_dir.readFileAlloc(allocator, entry.source, 9999999999);
        const generated = try gen.run(registry);

        const target = try std.fs.cwd().createFile(entry.target, .{
            .read = true,
            .truncate = false,
            .lock = .exclusive,
        });
        const bytes = try target.readToEndAlloc(allocator, 9999999999);
        var buffer = std.ArrayList(u8).fromOwnedSlice(allocator, bytes);

        const index = std.mem.indexOf(u8, bytes, insert_magic) orelse {
            std.debug.panic("target file is missing insert magic: {s}", .{entry.target});
        };

        buffer.items.len = index;
        try buffer.appendSlice(generated);

        try target.seekTo(0);
        try target.setEndPos(0);
        try target.writeAll(buffer.items);
    }
}

const gen = struct {
    const Interface = struct {
        common: bool = false,
        iid: []const u8,
        name: []const u8,
        parent: ?[]const u8,
        methods: []Method,
    };

    const Method = struct {
        name: []const u8,
        params: []const u8,
        returns: []const u8,
    };

    const Cache = std.StringHashMap(Interface);

    const trim = std.mem.trim;
    const eql = std.mem.eql;
    const startsWith = std.mem.startsWith;
    const endsWith = std.mem.endsWith;
    const expect = std.testing.expectEqualStrings;
    const indexOf = std.mem.indexOfScalar;
    const lastIndexOf = std.mem.lastIndexOfScalar;

    const whitespace = " " ++ "\t";

    fn run(registry: []const u8) ![]const u8 {
        var builder = Builder{ .inner = .init(allocator) };
        const cache, const order = try parse(registry);

        try builder.println(insert_magic, .{});

        for (order) |name| {
            const interface = cache.get(name).?;

            if (interface.common) continue;

            try builder.println("pub const {s} = extern struct {{", .{name});
            try builder.println(tab ++ "pub const IID = GUID.parse(\"{{{s}}}\");", .{interface.iid});
            try builder.println("", .{});
            try builder.println(tab ++ "vtable: *const VTable,", .{});
            try builder.println("", .{});
            try emitVTable(&builder, name, interface.parent, interface.methods);
            try emitMethods(&builder, name, interface.methods);
            try emitParent(&builder, &cache, name, interface.parent);
            try builder.println("}};\n", .{});
        }

        if (std.mem.endsWith(u8, builder.inner.items, "\n\n")) {
            builder.inner.items.len -= 1;
        }

        return builder.inner.items;
    }

    fn parse(registry: []const u8) !struct { Cache, [][]const u8 } {
        var cache: Cache = .initContext(allocator, .{});

        var iter = std.mem.tokenizeAny(u8, registry, "\n\r");
        var builder: Interface = undefined;
        var methods = std.BoundedArray(Method, 100){};

        var order = std.ArrayList([]const u8).init(allocator);

        const state: enum { start, iid, method, end } = .start;
        blk: switch (state) {
            .start => {
                const line = iter.next() orelse break :blk;
                var parts = std.mem.tokenizeScalar(u8, line, ' ');

                const define = parts.next().?;
                builder.common = eql(u8, define, "common");
                builder.name = parts.next().?;

                var parent: ?[]const u8 = null;
                if (parts.peek()) |p| {
                    if (eql(u8, p, ":")) {
                        _ = parts.next();
                        parent = parts.next().?;
                    }
                }
                builder.parent = parent;

                try expect("{", parts.next().?);
                continue :blk .iid;
            },
            .iid => {
                const line = iter.next().?;
                var parts = std.mem.tokenizeAny(u8, line, whitespace);

                try expect("iid", parts.next().?);
                try expect("=", parts.next().?);

                builder.iid = trim(u8, parts.next().?, "\"");

                if (iter.peek()) |next| {
                    if (startsWith(u8, trim(u8, next, whitespace), "fn")) {
                        continue :blk .method;
                    }
                }

                continue :blk .end;
            },
            .method => {
                const line = trim(u8, iter.next().?, whitespace);

                const paren_idx = indexOf(u8, line, '(').?;
                const ret_idx = lastIndexOf(u8, line, ' ').?;

                const name = line[3..paren_idx];
                var params = line[paren_idx + 1 .. ret_idx - 1];
                if (eql(u8, params, "self")) {
                    params = "";
                } else {
                    params = params[4..];
                }
                const rets = line[ret_idx + 1 ..];

                try methods.append(.{
                    .name = name,
                    .params = params,
                    .returns = rets,
                });

                if (iter.peek()) |next| {
                    if (startsWith(u8, trim(u8, next, whitespace), "fn")) {
                        continue :blk .method;
                    }
                }

                continue :blk .end;
            },
            .end => {
                const line = iter.next().?;
                try expect("}", line);

                try order.append(builder.name);

                builder.methods = try allocator.dupe(Method, methods.slice());
                try cache.put(builder.name, builder);
                builder = undefined;
                methods.len = 0;

                if (iter.peek() == null) {
                    break :blk;
                }

                continue :blk .start;
            },
        }

        return .{ cache, order.items };
    }

    fn emitVTable(builder: *Builder, name: []const u8, parent: ?[]const u8, methods: []Method) !void {
        try builder.println(tab ++ "const VTable = extern struct {{", .{});
        if (parent) |p| {
            try builder.println(dtab ++ "base: {s}.VTable,", .{p});
        }
        for (methods) |method| {
            try builder.println(dtab ++ "{!s}: *const fn (*{s}{s}) callconv(.winapi) {s},", .{ toSnake(method.name), name, method.params, method.returns });
        }
        try builder.println(tab ++ "}};", .{});
    }

    fn emitMethods(builder: *Builder, name: []const u8, methods: []Method) !void {
        if (methods.len == 0) return;

        try builder.println("", .{});

        for (methods) |method| {
            try builder.println(tab ++ "pub fn {s}(self: *{s}{s}) {s} {{", .{ method.name, name, method.params, method.returns });
            try builder.println(dtab ++ "return (self.vtable.{!s})(self{!s});", .{ toSnake(method.name), toArgs(method.params) });
            try builder.println(tab ++ "}}", .{});
        }
    }

    fn emitParent(builder: *Builder, cache: *const Cache, name: []const u8, parent: ?[]const u8) !void {
        if (parent) |p| {
            const interface = cache.get(p).?;

            try builder.println(tab ++ "// {s} methods", .{p});
            for (interface.methods) |method| {
                try builder.println(tab ++ "pub fn {s}(self: *{s}{s}) {s} {{", .{ method.name, name, method.params, method.returns });
                try builder.println(dtab ++ "return (@as(*const {s}.VTable, @ptrCast(self.vtable)).{!s})(@ptrCast(self){!s});", .{ p, toSnake(method.name), toArgs(method.params) });
                try builder.println(tab ++ "}}", .{});
            }

            try emitParent(builder, cache, name, interface.parent);
        }
    }

    fn toSnake(input: []const u8) ![]const u8 {
        var list = std.ArrayList(u8).init(allocator);

        for (input, 0..) |c, i| {
            if (std.ascii.isUpper(c)) {
                if (i != 0) {
                    try list.append('_');
                }
                try list.append(std.ascii.toLower(c));
            } else {
                try list.append(c);
            }
        }

        return list.items;
    }

    fn toArgs(params: []const u8) ![]const u8 {
        if (params.len == 0) return "";

        var builder = Builder{ .inner = .init(allocator) };

        try builder.print(", ", .{});

        var iter = std.mem.tokenizeSequence(u8, params, ", ");
        while (iter.next()) |part| {
            const idx = indexOf(u8, part, ':').?;
            try builder.print("{s}", .{part[0..idx]});
            if (iter.peek() != null) try builder.print(", ", .{});
        }

        return builder.inner.items;
    }
};

const Builder = struct {
    inner: std.ArrayList(u8),

    fn print(self: *Builder, comptime fmt: []const u8, args: anytype) !void {
        try self.inner.writer().print(fmt, args);
    }

    fn println(self: *Builder, comptime fmt: []const u8, args: anytype) !void {
        try self.inner.writer().print(fmt ++ "\n", args);
    }
};
