const std = @import("std");
const trim = std.mem.trim;

const tab = "    ";
const dtab = tab ++ tab;
const allocator = std.heap.smp_allocator;

const Cache = std.StringHashMap(struct {
    iid: []const u8,
    inheirit: ?[]const u8,
    vtable_def: []const u8,
    methods_def: []const u8,
});

const Interface = struct {
    iid: []const u8,
    name: []const u8,
    inheirit: ?[]const u8,
    vtable: []InterfaceFunction,
    common: bool = false,
};

const InterfaceFunction = struct {
    name: []const u8,
    args: []const u8,
    rets: []const u8,
};

const insert_magic =
    \\// THIS FILE IS AUTOGENERATED BEYOND THIS POINT! DO NOT EDIT!
    \\// ----------------------------------------------------------
    \\
;

const mapping = [_]struct {
    source: []const u8,
    target: []const u8,
}{
    .{ .source = "dxgi.zon", .target = "deps/w32/dxgi.zig" },
    .{ .source = "d3d12.zon", .target = "deps/w32/d3d12.zig" },
};

pub fn main() !void {
    const generator_dir = try std.fs.cwd().openDir("tools/generator", .{});

    for (mapping) |entry| {
        const zon_bytes = try generator_dir.readFileAlloc(allocator, entry.source, 9999999999);
        const generated = try generate(zon_bytes);

        const target = try std.fs.cwd().createFile(entry.target, .{
            .read = true,
            .truncate = false,
            .lock = .exclusive,
        });
        const bytes = try target.readToEndAlloc(allocator, 9999999999);
        var buffer = std.ArrayList(u8).fromOwnedSlice(allocator, bytes);

        const index = std.mem.indexOf(u8, bytes, insert_magic) orelse {
            std.debug.panic("target file is missing insert magic: {s}", .{entry.target});
        };

        buffer.items.len = index;
        try buffer.appendSlice(generated);

        try target.seekTo(0);
        try target.setEndPos(0);
        try target.writeAll(buffer.items);
    }
}

fn generate(zon_bytes: []const u8) ![]const u8 {
    var status = std.zon.parse.Status{};
    const parsed = std.zon.parse.fromSlice([]Interface, allocator, @ptrCast(zon_bytes), &status, .{}) catch {
        std.debug.panic("failed to parse zon: {}", .{status});
    };

    var cache: Cache = .init(allocator);

    for (parsed) |iface| {
        try cache.putNoClobber(iface.name, .{
            .iid = iface.iid,
            .inheirit = iface.inheirit,
            .vtable_def = try generateVTable(iface),
            .methods_def = try generateMethods(iface),
        });
    }

    var output = std.ArrayList(u8).init(allocator);
    var writer = output.writer();

    try writer.print(insert_magic ++ "\n", .{});

    for (parsed) |iface| {
        if (iface.common) continue;

        const name = iface.name;
        const info = cache.get(name).?;

        const parent_methods = try generateParentMethods(&cache, name, info.inheirit);

        try writer.print("pub const {s} = extern struct {{\n", .{name});
        try writer.print(tab ++ "pub const IID = GUID.parse(\"{{{s}}}\");\n\n", .{info.iid});
        try writer.print(tab ++ "vtable: *const VTable,\n\n", .{});
        try writer.print(tab ++ "const VTable = extern struct {{\n", .{});
        try writer.print("{s}\n", .{trim(u8, info.vtable_def, "\n")});
        try writer.print(tab ++ "}};\n\n", .{});
        if (info.methods_def.len != 0) {
            try writer.print(tab ++ "// {s} methods\n", .{name});
            try writer.print("{s}\n", .{trim(u8, info.methods_def, "\n")});
        }
        if (parent_methods.len != 0)
            try writer.print("{s}\n", .{trim(u8, parent_methods, "\n")});
        try writer.print("}};\n\n", .{});
    }

    return output.items;
}

fn generateVTable(iface: Interface) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    var writer = output.writer();

    if (iface.inheirit) |name| {
        try writer.print(dtab ++ "base: {s}.VTable,\n", .{name});
    }

    for (iface.vtable) |func| {
        try writer.print(dtab ++ "{s}: ", .{func.name});
        try writer.print("*const fn ({?s}) callconv(.winapi) {s},\n", .{ func.args, func.rets });
    }

    return output.items;
}

fn generateMethods(iface: Interface) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    var writer = output.writer();

    for (iface.vtable) |func| {
        try writer.print(tab ++ "pub fn {s}(self: {s}) {s} {{\n", .{ try toCamelCase(func.name), func.args, func.rets });
        try writer.print(dtab ++ "return (@as(*const {s}.VTable, @ptrCast(self.vtable)).{s})({s});\n", .{ iface.name, func.name, try toParams(func.args) });
        try writer.print(tab ++ "}}\n", .{});
    }

    return output.items;
}

fn generateParentMethods(store: *Cache, name: []const u8, _parent: ?[]const u8) ![]const u8 {
    var class = _parent;

    var output = std.ArrayList(u8).init(allocator);
    var writer = output.writer();

    while (class) |parent| {
        const info = store.get(parent) orelse {
            std.debug.panic("ERROR: unknown interface: {s} when generating {s}", .{ parent, name });
        };

        class = info.inheirit;

        if (info.methods_def.len == 0) continue;

        const needle = try std.fmt.allocPrint(allocator, "*{s}", .{parent});
        const replacement = try std.fmt.allocPrint(allocator, "*{s}", .{name});
        const updated = try std.mem.replaceOwned(u8, allocator, info.methods_def, needle, replacement);

        try writer.print(tab ++ "// {s} methods\n{s}", .{ parent, updated });
    }

    return output.items;
}

// helpers
// -------

fn toCamelCase(input: []const u8) ![]const u8 {
    const size = input.len - std.mem.count(u8, input, "_");
    const result = try allocator.alloc(u8, size);

    var resultIndex: usize = 0;
    var upperNext = false;

    var i: usize = 0;
    while (i < input.len) : (i += 1) {
        const c = input[i];
        if (c == '_') {
            upperNext = true;
        } else {
            if (upperNext) {
                result[resultIndex] = std.ascii.toUpper(c);
                upperNext = false;
            } else {
                result[resultIndex] = c;
            }
            resultIndex += 1;
        }
    }

    return result;
}

fn toParams(input: []const u8) ![]const u8 {
    if (input.len == 0) return "";

    var output = std.ArrayList(u8).init(allocator);
    var writer = output.writer();

    var iter = std.mem.splitSequence(u8, input, ", ");
    while (iter.next()) |substring| {
        const end = std.mem.indexOfScalar(u8, substring, ':') orelse substring.len;
        const name = substring[0..end];

        if (name[0] == '*') {
            try writer.print("@ptrCast(self), ", .{});
        } else {
            try writer.print("{s}, ", .{name});
        }
    }

    return trim(u8, output.items, ", ");
}
