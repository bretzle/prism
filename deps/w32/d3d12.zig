const std = @import("std");
const w32 = @import("windows.zig");
const dxgi = @import("dxgi.zig");
const os = std.os.windows;

const GUID = w32.GUID;
const HRESULT = w32.HRESULT;
const SIZE_T = w32.SIZE_T;
const UINT = w32.UINT;
const FLOAT = os.FLOAT;
const BOOL = w32.BOOL;
const INT = w32.INT;
const ULONG = w32.ULONG;
const RECT = w32.RECT;
const UINT64 = u64;
const UINT16 = u16;
const UINT8 = u8;
const HANDLE = w32.HANDLE;
const LPCSTR = w32.LPCSTR;

pub const IUnknown = w32.IUnknown;
pub const IObject = w32.IObject;

pub const PFN_MESSAGE_CALLBACK = *const fn (category: MESSAGE_CATEGORY, severity: MESSAGE_SEVERITY, id: MESSAGE_ID, description: [*c]const u8, context: ?*anyopaque) callconv(.winapi) void;

pub const GPU_VIRTUAL_ADDRESS = UINT64;

pub const DESCRIPTOR_RANGE_OFFSET_APPEND = 0xffffffff; // defined as -1
pub const RESOURCE_BARRIER_ALL_SUBRESOURCES = 0xffffffff;
pub const DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT = 0x400000;

pub const CPU_DESCRIPTOR_HANDLE = extern struct {
    ptr: UINT64,
};

pub const GPU_DESCRIPTOR_HANDLE = extern struct {
    ptr: UINT64,
};

pub const FEATURE_LEVEL = enum(u32) {
    @"1_0_CORE" = 0x1000,
    @"9_1" = 0x9100,
    @"9_2" = 0x9200,
    @"9_3" = 0x9300,
    @"10_0" = 0xA000,
    @"10_1" = 0xA100,
    @"11_0" = 0xB000,
    @"11_1" = 0xB100,
    @"12_0" = 0xC000,
    @"12_1" = 0xC100,
    @"12_2" = 0xC200,
};

pub const PRIMITIVE_TOPOLOGY = enum(UINT) {
    UNDEFINED = 0,
    POINTLIST = 1,
    LINELIST = 2,
    LINESTRIP = 3,
    TRIANGLELIST = 4,
    TRIANGLESTRIP = 5,
    LINELIST_ADJ = 10,
    LINESTRIP_ADJ = 11,
    TRIANGLELIST_ADJ = 12,
    TRIANGLESTRIP_ADJ = 13,
    CONTROL_POINT_PATCHLIST = 33,
    @"2_CONTROL_POINT_PATCHLIST" = 34,
    @"3_CONTROL_POINT_PATCHLIST" = 35,
    @"4_CONTROL_POINT_PATCHLIST" = 36,
    @"5_CONTROL_POINT_PATCHLIST" = 37,
    @"6_CONTROL_POINT_PATCHLIST" = 38,
    @"7_CONTROL_POINT_PATCHLIST" = 39,
    @"8_CONTROL_POINT_PATCHLIST" = 40,
    @"9_CONTROL_POINT_PATCHLIST" = 41,
    @"10_CONTROL_POINT_PATCHLIST" = 42,
    @"11_CONTROL_POINT_PATCHLIST" = 43,
    @"12_CONTROL_POINT_PATCHLIST" = 44,
    @"13_CONTROL_POINT_PATCHLIST" = 45,
    @"14_CONTROL_POINT_PATCHLIST" = 46,
    @"15_CONTROL_POINT_PATCHLIST" = 47,
    @"16_CONTROL_POINT_PATCHLIST" = 48,
    @"17_CONTROL_POINT_PATCHLIST" = 49,
    @"18_CONTROL_POINT_PATCHLIST" = 50,
    @"19_CONTROL_POINT_PATCHLIST" = 51,
    @"20_CONTROL_POINT_PATCHLIST" = 52,
    @"21_CONTROL_POINT_PATCHLIST" = 53,
    @"22_CONTROL_POINT_PATCHLIST" = 54,
    @"23_CONTROL_POINT_PATCHLIST" = 55,
    @"24_CONTROL_POINT_PATCHLIST" = 56,
    @"25_CONTROL_POINT_PATCHLIST" = 57,
    @"26_CONTROL_POINT_PATCHLIST" = 58,
    @"27_CONTROL_POINT_PATCHLIST" = 59,
    @"28_CONTROL_POINT_PATCHLIST" = 60,
    @"29_CONTROL_POINT_PATCHLIST" = 61,
    @"30_CONTROL_POINT_PATCHLIST" = 62,
    @"31_CONTROL_POINT_PATCHLIST" = 63,
    @"32_CONTROL_POINT_PATCHLIST" = 64,
};

pub const FILTER = enum(UINT) {
    MIN_MAG_MIP_POINT = 0,
    MIN_MAG_POINT_MIP_LINEAR = 0x1,
    MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4,
    MIN_POINT_MAG_MIP_LINEAR = 0x5,
    MIN_LINEAR_MAG_MIP_POINT = 0x10,
    MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    MIN_MAG_LINEAR_MIP_POINT = 0x14,
    MIN_MAG_MIP_LINEAR = 0x15,
    ANISOTROPIC = 0x55,
    COMPARISON_MIN_MAG_MIP_POINT = 0x80,
    COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,
    COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,
    COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,
    COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,
    COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91,
    COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,
    COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,
    COMPARISON_ANISOTROPIC = 0xd5,
    MINIMUM_MIN_MAG_MIP_POINT = 0x100,
    MINIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x101,
    MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x104,
    MINIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x105,
    MINIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x110,
    MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x111,
    MINIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x114,
    MINIMUM_MIN_MAG_MIP_LINEAR = 0x115,
    MINIMUM_ANISOTROPIC = 0x155,
    MAXIMUM_MIN_MAG_MIP_POINT = 0x180,
    MAXIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x181,
    MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x184,
    MAXIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x185,
    MAXIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x190,
    MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x191,
    MAXIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x194,
    MAXIMUM_MIN_MAG_MIP_LINEAR = 0x195,
    MAXIMUM_ANISOTROPIC = 0x1d5,
};

pub const STATIC_BORDER_COLOR = enum(UINT) {
    TRANSPARENT_BLACK = 0,
    OPAQUE_BLACK = 1,
    OPAQUE_WHITE = 2,
};

pub const TEXTURE_ADDRESS_MODE = enum(UINT) {
    WRAP = 1,
    MIRROR = 2,
    CLAMP = 3,
    BORDER = 4,
    MIRROR_ONCE = 5,
};

pub const COMPARISON_FUNC = enum(UINT) {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8,
};

pub const STATIC_SAMPLER_DESC = extern struct {
    Filter: FILTER,
    AddressU: TEXTURE_ADDRESS_MODE,
    AddressV: TEXTURE_ADDRESS_MODE,
    AddressW: TEXTURE_ADDRESS_MODE,
    MipLODBias: FLOAT,
    MaxAnisotropy: UINT,
    ComparisonFunc: COMPARISON_FUNC,
    BorderColor: STATIC_BORDER_COLOR,
    MinLOD: FLOAT,
    MaxLOD: FLOAT,
    ShaderRegister: UINT,
    RegisterSpace: UINT,
    ShaderVisibility: SHADER_VISIBILITY,
};

pub const ROOT_SIGNATURE_FLAGS = packed struct(UINT) {
    ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT: bool = false,
    DENY_VERTEX_SHADER_ROOT_ACCESS: bool = false,
    DENY_HULL_SHADER_ROOT_ACCESS: bool = false,
    DENY_DOMAIN_SHADER_ROOT_ACCESS: bool = false,
    DENY_GEOMETRY_SHADER_ROOT_ACCESS: bool = false,
    DENY_PIXEL_SHADER_ROOT_ACCESS: bool = false,
    ALLOW_STREAM_OUTPUT: bool = false,
    LOCAL_ROOT_SIGNATURE: bool = false,
    DENY_AMPLIFICATION_SHADER_ROOT_ACCESS: bool = false,
    DENY_MESH_SHADER_ROOT_ACCESS: bool = false,
    CBV_SRV_UAV_HEAP_DIRECTLY_INDEXED: bool = false,
    SAMPLER_HEAP_DIRECTLY_INDEXED: bool = false,
    __unused: u20 = 0,
};

pub const ROOT_PARAMETER_TYPE = enum(UINT) {
    DESCRIPTOR_TABLE = 0,
    @"32BIT_CONSTANTS" = 1,
    CBV = 2,
    SRV = 3,
    UAV = 4,
};

pub const SHADER_VISIBILITY = enum(UINT) {
    ALL = 0,
    VERTEX = 1,
    HULL = 2,
    DOMAIN = 3,
    GEOMETRY = 4,
    PIXEL = 5,
    AMPLIFICATION = 6,
    MESH = 7,
};

pub const DESCRIPTOR_RANGE_TYPE = enum(UINT) {
    SRV = 0,
    UAV = 1,
    CBV = 2,
    SAMPLER = 3,
};

pub const DESCRIPTOR_RANGE = extern struct {
    RangeType: DESCRIPTOR_RANGE_TYPE,
    NumDescriptors: UINT,
    BaseShaderRegister: UINT,
    RegisterSpace: UINT,
    OffsetInDescriptorsFromTableStart: UINT,
};

pub const ROOT_DESCRIPTOR_TABLE = extern struct {
    NumDescriptorRanges: UINT,
    pDescriptorRanges: ?[*]const DESCRIPTOR_RANGE,
};

pub const ROOT_CONSTANTS = extern struct {
    ShaderRegister: UINT,
    RegisterSpace: UINT,
    Num32BitValues: UINT,
};

pub const ROOT_DESCRIPTOR = extern struct {
    ShaderRegister: UINT,
    RegisterSpace: UINT,
};

pub const ROOT_PARAMETER = extern struct {
    ParameterType: ROOT_PARAMETER_TYPE,
    u: extern union {
        DescriptorTable: ROOT_DESCRIPTOR_TABLE,
        Constants: ROOT_CONSTANTS,
        Descriptor: ROOT_DESCRIPTOR,
    },
    ShaderVisibility: SHADER_VISIBILITY,
};

pub const ROOT_SIGNATURE_DESC = extern struct {
    NumParameters: UINT,
    pParameters: ?[*]const ROOT_PARAMETER,
    NumStaticSamplers: UINT,
    pStaticSamplers: ?[*]const STATIC_SAMPLER_DESC,
    Flags: ROOT_SIGNATURE_FLAGS,
};

pub const ROOT_SIGNATURE_VERSION = enum(UINT) {
    VERSION_1_0 = 0x1,
    VERSION_1_1 = 0x2,
};

pub const FEATURE = enum(UINT) {
    OPTIONS = 0,
    ARCHITECTURE = 1,
    FEATURE_LEVELS = 2,
    FORMAT_SUPPORT = 3,
    MULTISAMPLE_QUALITY_LEVELS = 4,
    FORMAT_INFO = 5,
    GPU_VIRTUAL_ADDRESS_SUPPORT = 6,
    SHADER_MODEL = 7,
    OPTIONS1 = 8,
    PROTECTED_RESOURCE_SESSION_SUPPORT = 10,
    ROOT_SIGNATURE = 12,
    ARCHITECTURE1 = 16,
    OPTIONS2 = 18,
    SHADER_CACHE = 19,
    COMMAND_QUEUE_PRIORITY = 20,
    OPTIONS3 = 21,
    EXISTING_HEAPS = 22,
    OPTIONS4 = 23,
    SERIALIZATION = 24,
    CROSS_NODE = 25,
    OPTIONS5 = 27,
    DISPLAYABLE = 28,
    OPTIONS6 = 30,
    QUERY_META_COMMAND = 31,
    OPTIONS7 = 32,
    PROTECTED_RESOURCE_SESSION_TYPE_COUNT = 33,
    PROTECTED_RESOURCE_SESSION_TYPES = 34,
    OPTIONS8 = 36,
    OPTIONS9 = 37,
    OPTIONS10 = 39,
    OPTIONS11 = 40,
    OPTIONS12 = 41,
    OPTIONS13 = 42,
    OPTIONS14 = 43,
    OPTIONS15 = 44,
    OPTIONS16 = 45,
    OPTIONS17 = 46,
    OPTIONS18 = 47,
    OPTIONS19 = 48,
    OPTIONS20 = 49,
};

pub const FEATURE_DATA_ARCHITECTURE = extern struct {
    NodeIndex: UINT = 0,
    TileBasedRenderer: BOOL = 0,
    UMA: BOOL = 0,
    CacheCoherentUMA: BOOL = 0,
};

pub const FEATURE_DATA_OPTIONS16 = extern struct {
    DynamicDepthBiasSupported: BOOL,
    GPUUploadHeapSupported: BOOL,
};

pub const COMMAND_LIST_TYPE = enum(UINT) {
    DIRECT = 0,
    BUNDLE = 1,
    COMPUTE = 2,
    COPY = 3,
    VIDEO_DECODE = 4,
    VIDEO_PROCESS = 5,
    VIDEO_ENCODE = 6,
};

pub const COMMAND_QUEUE_FLAGS = packed struct(UINT) {
    DISABLE_GPU_TIMEOUT: bool = false,
    __unused: u31 = 0,
};

pub const COMMAND_QUEUE_DESC = extern struct {
    Type: COMMAND_LIST_TYPE,
    Priority: INT,
    Flags: COMMAND_QUEUE_FLAGS,
    NodeMask: UINT,
};

pub const INDIRECT_ARGUMENT_TYPE = enum(UINT) {
    DRAW = 0,
    DRAW_INDEXED = 1,
    DISPATCH = 2,
    VERTEX_BUFFER_VIEW = 3,
    INDEX_BUFFER_VIEW = 4,
    CONSTANT = 5,
    CONSTANT_BUFFER_VIEW = 6,
    SHADER_RESOURCE_VIEW = 7,
    UNORDERED_ACCESS_VIEW = 8,
    DISPATCH_RAYS = 9,
    DISPATCH_MESH = 10,
};

pub const INDIRECT_ARGUMENT_DESC = extern struct {
    Type: INDIRECT_ARGUMENT_TYPE,
    u: extern union {
        VertexBuffer: extern struct {
            Slot: UINT,
        },
        Constant: extern struct {
            RootParameterIndex: UINT,
            DestOffsetIn32BitValues: UINT,
            Num32BitValuesToSet: UINT,
        },
        ConstantBufferView: extern struct {
            RootParameterIndex: UINT,
        },
        ShaderResourceView: extern struct {
            RootParameterIndex: UINT,
        },
        UnorderedAccessView: extern struct {
            RootParameterIndex: UINT,
        },
    },
};

pub const COMMAND_SIGNATURE_DESC = extern struct {
    ByteStride: UINT,
    NumArgumentDescs: UINT,
    pArgumentDescs: *const INDIRECT_ARGUMENT_DESC,
    NodeMask: UINT,
};

pub const RANGE = extern struct {
    Begin: UINT64,
    End: UINT64,
};

pub const BOX = extern struct {
    left: UINT,
    top: UINT,
    front: UINT,
    right: UINT,
    bottom: UINT,
    back: UINT,
};

pub const RESOURCE_DIMENSION = enum(UINT) {
    UNKNOWN = 0,
    BUFFER = 1,
    TEXTURE1D = 2,
    TEXTURE2D = 3,
    TEXTURE3D = 4,
};

pub const TEXTURE_LAYOUT = enum(UINT) {
    UNKNOWN = 0,
    ROW_MAJOR = 1,
    @"64KB_UNDEFINED_SWIZZLE" = 2,
    @"64KB_STANDARD_SWIZZLE" = 3,
};

pub const RESOURCE_FLAGS = packed struct(UINT) {
    ALLOW_RENDER_TARGET: bool = false,
    ALLOW_DEPTH_STENCIL: bool = false,
    ALLOW_UNORDERED_ACCESS: bool = false,
    DENY_SHADER_RESOURCE: bool = false,
    ALLOW_CROSS_ADAPTER: bool = false,
    ALLOW_SIMULTANEOUS_ACCESS: bool = false,
    VIDEO_DECODE_REFERENCE_ONLY: bool = false,
    VIDEO_ENCODE_REFERENCE_ONLY: bool = false,
    __unused: u24 = 0,
};

pub const RESOURCE_DESC = extern struct {
    Dimension: RESOURCE_DIMENSION,
    Alignment: UINT64,
    Width: UINT64,
    Height: UINT,
    DepthOrArraySize: UINT16,
    MipLevels: UINT16,
    Format: dxgi.FORMAT,
    SampleDesc: dxgi.SAMPLE_DESC,
    Layout: TEXTURE_LAYOUT,
    Flags: RESOURCE_FLAGS,
};

pub const VIEWPORT = extern struct {
    TopLeftX: FLOAT,
    TopLeftY: FLOAT,
    Width: FLOAT,
    Height: FLOAT,
    MinDepth: FLOAT,
    MaxDepth: FLOAT,
};

pub const HEAP_TYPE = enum(UINT) {
    DEFAULT = 1,
    UPLOAD = 2,
    READBACK = 3,
    CUSTOM = 4,
};

pub const CPU_PAGE_PROPERTY = enum(UINT) {
    UNKNOWN = 0,
    NOT_AVAILABLE = 1,
    WRITE_COMBINE = 2,
    WRITE_BACK = 3,
};

pub const MEMORY_POOL = enum(UINT) {
    UNKNOWN = 0,
    L0 = 1,
    L1 = 2,
};

pub const HEAP_PROPERTIES = extern struct {
    Type: HEAP_TYPE,
    CPUPageProperty: CPU_PAGE_PROPERTY,
    MemoryPoolPreference: MEMORY_POOL,
    CreationNodeMask: UINT,
    VisibleNodeMask: UINT,
};

pub const HEAP_FLAGS = packed struct(UINT) {
    SHARED: bool = false,
    __unused1: bool = false,
    DENY_BUFFERS: bool = false,
    ALLOW_DISPLAY: bool = false,
    __unused4: bool = false,
    SHARED_CROSS_ADAPTER: bool = false,
    DENY_RT_DS_TEXTURES: bool = false,
    DENY_NON_RT_DS_TEXTURES: bool = false,
    HARDWARE_PROTECTED: bool = false,
    ALLOW_WRITE_WATCH: bool = false,
    ALLOW_SHADER_ATOMICS: bool = false,
    CREATE_NOT_RESIDENT: bool = false,
    CREATE_NOT_ZEROED: bool = false,
    __unused: u19 = 0,

    pub const ALLOW_ALL_BUFFERS_AND_TEXTURES = HEAP_FLAGS{};
    pub const ALLOW_ONLY_RT_DS_TEXTURES = HEAP_FLAGS{ .DENY_BUFFERS = true, .DENY_NON_RT_DS_TEXTURES = true };
    pub const ALLOW_ONLY_NON_RT_DS_TEXTURES = HEAP_FLAGS{ .DENY_BUFFERS = true, .DENY_RT_DS_TEXTURES = true };
    pub const ALLOW_ONLY_BUFFERS = HEAP_FLAGS{ .DENY_RT_DS_TEXTURES = true, .DENY_NON_RT_DS_TEXTURES = true };
    pub const HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES = HEAP_FLAGS{
        .DENY_BUFFERS = true,
        .DENY_NON_RT_DS_TEXTURES = true,
    };
};

pub const SUBRESOURCE_FOOTPRINT = extern struct {
    Format: dxgi.FORMAT,
    Width: UINT,
    Height: UINT,
    Depth: UINT,
    RowPitch: UINT,
};

pub const PLACED_SUBRESOURCE_FOOTPRINT = extern struct {
    Offset: UINT64,
    Footprint: SUBRESOURCE_FOOTPRINT,
};

pub const TEXTURE_COPY_TYPE = enum(UINT) {
    SUBRESOURCE_INDEX = 0,
    PLACED_FOOTPRINT = 1,
};

pub const TEXTURE_COPY_LOCATION = extern struct {
    pResource: *IResource,
    Type: TEXTURE_COPY_TYPE,
    u: extern union {
        PlacedFootprint: PLACED_SUBRESOURCE_FOOTPRINT,
        SubresourceIndex: UINT,
    },
};

pub const TILED_RESOURCE_COORDINATE = extern struct {
    X: UINT,
    Y: UINT,
    Z: UINT,
    Subresource: UINT,
};

pub const TILE_REGION_SIZE = extern struct {
    NumTiles: UINT,
    UseBox: BOOL,
    Width: UINT,
    Height: UINT16,
    Depth: UINT16,
};

pub const TILE_COPY_FLAGS = packed struct(UINT) {
    NO_HAZARD: bool = false,
    LINEAR_BUFFER_TO_SWIZZLED_TILED_RESOURCE: bool = false,
    SWIZZLED_TILED_RESOURCE_TO_LINEAR_BUFFER: bool = false,
    __unused: u29 = 0,
};

pub const RESOURCE_BARRIER_TYPE = enum(UINT) {
    TRANSITION = 0,
    ALIASING = 1,
    UAV = 2,
};

pub const RESOURCE_STATES = packed struct(UINT) {
    VERTEX_AND_CONSTANT_BUFFER: bool = false, // 0x1
    INDEX_BUFFER: bool = false,
    RENDER_TARGET: bool = false,
    UNORDERED_ACCESS: bool = false,
    DEPTH_WRITE: bool = false, // 0x10
    DEPTH_READ: bool = false,
    NON_PIXEL_SHADER_RESOURCE: bool = false,
    PIXEL_SHADER_RESOURCE: bool = false,
    STREAM_OUT: bool = false, // 0x100
    INDIRECT_ARGUMENT_OR_PREDICATION: bool = false,
    COPY_DEST: bool = false,
    COPY_SOURCE: bool = false,
    RESOLVE_DEST: bool = false, // 0x1000
    RESOLVE_SOURCE: bool = false,
    __unused14: bool = false,
    __unused15: bool = false,
    VIDEO_DECODE_READ: bool = false, // 0x10000
    VIDEO_DECODE_WRITE: bool = false,
    VIDEO_PROCESS_READ: bool = false,
    VIDEO_PROCESS_WRITE: bool = false,
    __unused20: bool = false, // 0x100000
    VIDEO_ENCODE_READ: bool = false,
    RAYTRACING_ACCELERATION_STRUCTURE: bool = false,
    VIDEO_ENCODE_WRITE: bool = false,
    SHADING_RATE_SOURCE: bool = false, // 0x1000000
    __unused: u7 = 0,

    pub const COMMON = RESOURCE_STATES{};
    pub const PRESENT = RESOURCE_STATES{};
    pub const GENERIC_READ = RESOURCE_STATES{
        .VERTEX_AND_CONSTANT_BUFFER = true,
        .INDEX_BUFFER = true,
        .NON_PIXEL_SHADER_RESOURCE = true,
        .PIXEL_SHADER_RESOURCE = true,
        .INDIRECT_ARGUMENT_OR_PREDICATION = true,
        .COPY_SOURCE = true,
    };
    pub const ALL_SHADER_RESOURCE = RESOURCE_STATES{
        .NON_PIXEL_SHADER_RESOURCE = true,
        .PIXEL_SHADER_RESOURCE = true,
    };
};

pub const RESOURCE_TRANSITION_BARRIER = extern struct {
    pResource: *IResource,
    Subresource: UINT,
    StateBefore: RESOURCE_STATES,
    StateAfter: RESOURCE_STATES,
};

pub const RESOURCE_ALIASING_BARRIER = extern struct {
    pResourceBefore: ?*IResource,
    pResourceAfter: ?*IResource,
};

pub const RESOURCE_UAV_BARRIER = extern struct {
    pResource: ?*IResource,
};

pub const RESOURCE_BARRIER_FLAGS = packed struct(UINT) {
    BEGIN_ONLY: bool = false,
    END_ONLY: bool = false,
    __unused: u30 = 0,
};

pub const RESOURCE_BARRIER = extern struct {
    Type: RESOURCE_BARRIER_TYPE,
    Flags: RESOURCE_BARRIER_FLAGS,
    u: extern union {
        Transition: RESOURCE_TRANSITION_BARRIER,
        Aliasing: RESOURCE_ALIASING_BARRIER,
        UAV: RESOURCE_UAV_BARRIER,
    },
};

pub const VERTEX_BUFFER_VIEW = extern struct {
    BufferLocation: GPU_VIRTUAL_ADDRESS,
    SizeInBytes: UINT,
    StrideInBytes: UINT,
};

pub const INDEX_BUFFER_VIEW = extern struct {
    BufferLocation: GPU_VIRTUAL_ADDRESS,
    SizeInBytes: UINT,
    Format: dxgi.FORMAT,
};

pub const STREAM_OUTPUT_BUFFER_VIEW = extern struct {
    BufferLocation: GPU_VIRTUAL_ADDRESS,
    SizeInBytes: UINT64,
    BufferFilledSizeLocation: GPU_VIRTUAL_ADDRESS,
};

pub const CLEAR_FLAGS = packed struct(UINT) {
    DEPTH: bool = false,
    STENCIL: bool = false,
    __unused: u30 = 0,
};

pub const DISCARD_REGION = extern struct {
    NumRects: UINT,
    pRects: *const RECT,
    FirstSubresource: UINT,
    NumSubresources: UINT,
};

pub const PREDICATION_OP = enum(UINT) {
    EQUAL_ZERO = 0,
    NOT_EQUAL_ZERO = 1,
};

pub const QUERY_TYPE = enum(UINT) {
    OCCLUSION = 0,
    BINARY_OCCLUSION = 1,
    TIMESTAMP = 2,
    PIPELINE_STATISTICS = 3,
    SO_STATISTICS_STREAM0 = 4,
    SO_STATISTICS_STREAM1 = 5,
    SO_STATISTICS_STREAM2 = 6,
    SO_STATISTICS_STREAM3 = 7,
    VIDEO_DECODE_STATISTICS = 8,
    PIPELINE_STATISTICS1 = 10,
};

pub const DESCRIPTOR_HEAP_TYPE = enum(UINT) {
    CBV_SRV_UAV = 0,
    SAMPLER = 1,
    RTV = 2,
    DSV = 3,
};

pub const DESCRIPTOR_HEAP_FLAGS = packed struct(UINT) {
    SHADER_VISIBLE: bool = false,
    __unused: u31 = 0,
};

pub const DESCRIPTOR_HEAP_DESC = extern struct {
    Type: DESCRIPTOR_HEAP_TYPE,
    NumDescriptors: UINT,
    Flags: DESCRIPTOR_HEAP_FLAGS,
    NodeMask: UINT,
};

pub const FENCE_FLAGS = packed struct(UINT) {
    SHARED: bool = false,
    SHARED_CROSS_ADAPTER: bool = false,
    NON_MONITORED: bool = false,
    __unused: u29 = 0,
};

pub const MESSAGE_CATEGORY = enum(u32) {
    APPLICATION_DEFINED = 0,
    MISCELLANEOUS = 1,
    INITIALIZATION = 2,
    CLEANUP = 3,
    COMPILATION = 4,
    STATE_CREATION = 5,
    STATE_SETTING = 6,
    STATE_GETTING = 7,
    RESOURCE_MANIPULATION = 8,
    EXECUTION = 9,
    SHADER = 10,
};

pub const MESSAGE_SEVERITY = enum(u32) {
    CORRUPTION = 0,
    ERROR = 1,
    WARNING = 2,
    INFO = 3,
    MESSAGE = 4,
};

pub const MESSAGE_ID = enum(u32) {
    UNKNOWN = 0,
    STRING_FROM_APPLICATION = 1,
    CORRUPTED_THIS = 2,
    CORRUPTED_PARAMETER1 = 3,
    CORRUPTED_PARAMETER2 = 4,
    CORRUPTED_PARAMETER3 = 5,
    CORRUPTED_PARAMETER4 = 6,
    CORRUPTED_PARAMETER5 = 7,
    CORRUPTED_PARAMETER6 = 8,
    CORRUPTED_PARAMETER7 = 9,
    CORRUPTED_PARAMETER8 = 10,
    CORRUPTED_PARAMETER9 = 11,
    CORRUPTED_PARAMETER10 = 12,
    CORRUPTED_PARAMETER11 = 13,
    CORRUPTED_PARAMETER12 = 14,
    CORRUPTED_PARAMETER13 = 15,
    CORRUPTED_PARAMETER14 = 16,
    CORRUPTED_PARAMETER15 = 17,
    CORRUPTED_MULTITHREADING = 18,
    MESSAGE_REPORTING_OUTOFMEMORY = 19,
    GETPRIVATEDATA_MOREDATA = 20,
    SETPRIVATEDATA_INVALIDFREEDATA = 21,
    SETPRIVATEDATA_CHANGINGPARAMS = 24,
    SETPRIVATEDATA_OUTOFMEMORY = 25,
    CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT = 26,
    CREATESHADERRESOURCEVIEW_INVALIDDESC = 27,
    CREATESHADERRESOURCEVIEW_INVALIDFORMAT = 28,
    CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANESLICE = 29,
    CREATESHADERRESOURCEVIEW_INVALIDPLANESLICE = 30,
    CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS = 31,
    CREATESHADERRESOURCEVIEW_INVALIDRESOURCE = 32,
    CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT = 35,
    CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT = 36,
    CREATERENDERTARGETVIEW_INVALIDDESC = 37,
    CREATERENDERTARGETVIEW_INVALIDFORMAT = 38,
    CREATERENDERTARGETVIEW_INVALIDVIDEOPLANESLICE = 39,
    CREATERENDERTARGETVIEW_INVALIDPLANESLICE = 40,
    CREATERENDERTARGETVIEW_INVALIDDIMENSIONS = 41,
    CREATERENDERTARGETVIEW_INVALIDRESOURCE = 42,
    CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT = 45,
    CREATEDEPTHSTENCILVIEW_INVALIDDESC = 46,
    CREATEDEPTHSTENCILVIEW_INVALIDFORMAT = 47,
    CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS = 48,
    CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE = 49,
    CREATEINPUTLAYOUT_OUTOFMEMORY = 52,
    CREATEINPUTLAYOUT_TOOMANYELEMENTS = 53,
    CREATEINPUTLAYOUT_INVALIDFORMAT = 54,
    CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT = 55,
    CREATEINPUTLAYOUT_INVALIDSLOT = 56,
    CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS = 57,
    CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH = 58,
    CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE = 59,
    CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE = 60,
    CREATEINPUTLAYOUT_INVALIDALIGNMENT = 61,
    CREATEINPUTLAYOUT_DUPLICATESEMANTIC = 62,
    CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE = 63,
    CREATEINPUTLAYOUT_NULLSEMANTIC = 64,
    CREATEINPUTLAYOUT_MISSINGELEMENT = 65,
    CREATEVERTEXSHADER_OUTOFMEMORY = 66,
    CREATEVERTEXSHADER_INVALIDSHADERBYTECODE = 67,
    CREATEVERTEXSHADER_INVALIDSHADERTYPE = 68,
    CREATEGEOMETRYSHADER_OUTOFMEMORY = 69,
    CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE = 70,
    CREATEGEOMETRYSHADER_INVALIDSHADERTYPE = 71,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY = 72,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE = 73,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE = 74,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES = 75,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED = 76,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED = 79,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT = 80,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT = 81,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT = 82,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT = 83,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION = 84,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT = 85,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE = 86,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC = 87,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH = 88,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS = 89,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX = 90,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE = 91,
    CREATEPIXELSHADER_OUTOFMEMORY = 92,
    CREATEPIXELSHADER_INVALIDSHADERBYTECODE = 93,
    CREATEPIXELSHADER_INVALIDSHADERTYPE = 94,
    CREATERASTERIZERSTATE_INVALIDFILLMODE = 95,
    CREATERASTERIZERSTATE_INVALIDCULLMODE = 96,
    CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP = 97,
    CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS = 98,
    CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK = 100,
    CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC = 101,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP = 102,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP = 103,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP = 104,
    CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC = 105,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP = 106,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP = 107,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP = 108,
    CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC = 109,
    CREATEBLENDSTATE_INVALIDSRCBLEND = 111,
    CREATEBLENDSTATE_INVALIDDESTBLEND = 112,
    CREATEBLENDSTATE_INVALIDBLENDOP = 113,
    CREATEBLENDSTATE_INVALIDSRCBLENDALPHA = 114,
    CREATEBLENDSTATE_INVALIDDESTBLENDALPHA = 115,
    CREATEBLENDSTATE_INVALIDBLENDOPALPHA = 116,
    CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK = 117,
    CLEARDEPTHSTENCILVIEW_INVALID = 135,
    COMMAND_LIST_DRAW_ROOT_SIGNATURE_NOT_SET = 200,
    COMMAND_LIST_DRAW_ROOT_SIGNATURE_MISMATCH = 201,
    COMMAND_LIST_DRAW_VERTEX_BUFFER_NOT_SET = 202,
    COMMAND_LIST_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL = 209,
    COMMAND_LIST_DRAW_VERTEX_BUFFER_TOO_SMALL = 210,
    COMMAND_LIST_DRAW_INDEX_BUFFER_NOT_SET = 211,
    COMMAND_LIST_DRAW_INDEX_BUFFER_FORMAT_INVALID = 212,
    COMMAND_LIST_DRAW_INDEX_BUFFER_TOO_SMALL = 213,
    COMMAND_LIST_DRAW_INVALID_PRIMITIVETOPOLOGY = 219,
    COMMAND_LIST_DRAW_VERTEX_STRIDE_UNALIGNED = 221,
    COMMAND_LIST_DRAW_INDEX_OFFSET_UNALIGNED = 222,
    DEVICE_REMOVAL_PROCESS_AT_FAULT = 232,
    DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT = 233,
    DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT = 234,
    CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC = 239,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC = 240,
    CREATEINPUTLAYOUT_TYPE_MISMATCH = 245,
    CREATEINPUTLAYOUT_EMPTY_LAYOUT = 253,
    LIVE_OBJECT_SUMMARY = 255,
    LIVE_DEVICE = 274,
    LIVE_SWAPCHAIN = 275,
    CREATEDEPTHSTENCILVIEW_INVALIDFLAGS = 276,
    CREATEVERTEXSHADER_INVALIDCLASSLINKAGE = 277,
    CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE = 278,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER = 280,
    CREATEPIXELSHADER_INVALIDCLASSLINKAGE = 283,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM = 284,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES = 285,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES = 286,
    CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES = 287,
    CREATEHULLSHADER_OUTOFMEMORY = 289,
    CREATEHULLSHADER_INVALIDSHADERBYTECODE = 290,
    CREATEHULLSHADER_INVALIDSHADERTYPE = 291,
    CREATEHULLSHADER_INVALIDCLASSLINKAGE = 292,
    CREATEDOMAINSHADER_OUTOFMEMORY = 294,
    CREATEDOMAINSHADER_INVALIDSHADERBYTECODE = 295,
    CREATEDOMAINSHADER_INVALIDSHADERTYPE = 296,
    CREATEDOMAINSHADER_INVALIDCLASSLINKAGE = 297,
    RESOURCE_UNMAP_NOTMAPPED = 310,
    DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE = 318,
    CREATECOMPUTESHADER_OUTOFMEMORY = 321,
    CREATECOMPUTESHADER_INVALIDSHADERBYTECODE = 322,
    CREATECOMPUTESHADER_INVALIDCLASSLINKAGE = 323,
    DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED = 331,
    DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED = 332,
    DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED = 333,
    DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED = 334,
    DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED = 335,
    DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED = 336,
    DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED = 337,
    CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE = 340,
    CREATEUNORDEREDACCESSVIEW_INVALIDDESC = 341,
    CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT = 342,
    CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANESLICE = 343,
    CREATEUNORDEREDACCESSVIEW_INVALIDPLANESLICE = 344,
    CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS = 345,
    CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT = 346,
    CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS = 354,
    CREATERASTERIZERSTATE_INVALIDFORCEDSAMPLECOUNT = 401,
    CREATEBLENDSTATE_INVALIDLOGICOPS = 403,
    DEVICE_CREATEVERTEXSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = 410,
    DEVICE_CREATEHULLSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = 412,
    DEVICE_CREATEDOMAINSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = 414,
    DEVICE_CREATEGEOMETRYSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = 416,
    DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEEXTENSIONSNOTSUPPORTED = 418,
    DEVICE_CREATEPIXELSHADER_DOUBLEEXTENSIONSNOTSUPPORTED = 420,
    DEVICE_CREATECOMPUTESHADER_DOUBLEEXTENSIONSNOTSUPPORTED = 422,
    DEVICE_CREATEVERTEXSHADER_UAVSNOTSUPPORTED = 425,
    DEVICE_CREATEHULLSHADER_UAVSNOTSUPPORTED = 426,
    DEVICE_CREATEDOMAINSHADER_UAVSNOTSUPPORTED = 427,
    DEVICE_CREATEGEOMETRYSHADER_UAVSNOTSUPPORTED = 428,
    DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UAVSNOTSUPPORTED = 429,
    DEVICE_CREATEPIXELSHADER_UAVSNOTSUPPORTED = 430,
    DEVICE_CREATECOMPUTESHADER_UAVSNOTSUPPORTED = 431,
    DEVICE_CLEARVIEW_INVALIDSOURCERECT = 447,
    DEVICE_CLEARVIEW_EMPTYRECT = 448,
    UPDATETILEMAPPINGS_INVALID_PARAMETER = 493,
    COPYTILEMAPPINGS_INVALID_PARAMETER = 494,
    CREATEDEVICE_INVALIDARGS = 506,
    CREATEDEVICE_WARNING = 507,
    RESOURCE_BARRIER_INVALID_TYPE = 519,
    RESOURCE_BARRIER_NULL_POINTER = 520,
    RESOURCE_BARRIER_INVALID_SUBRESOURCE = 521,
    RESOURCE_BARRIER_RESERVED_BITS = 522,
    RESOURCE_BARRIER_MISSING_BIND_FLAGS = 523,
    RESOURCE_BARRIER_MISMATCHING_MISC_FLAGS = 524,
    RESOURCE_BARRIER_MATCHING_STATES = 525,
    RESOURCE_BARRIER_INVALID_COMBINATION = 526,
    RESOURCE_BARRIER_BEFORE_AFTER_MISMATCH = 527,
    RESOURCE_BARRIER_INVALID_RESOURCE = 528,
    RESOURCE_BARRIER_SAMPLE_COUNT = 529,
    RESOURCE_BARRIER_INVALID_FLAGS = 530,
    RESOURCE_BARRIER_INVALID_COMBINED_FLAGS = 531,
    RESOURCE_BARRIER_INVALID_FLAGS_FOR_FORMAT = 532,
    RESOURCE_BARRIER_INVALID_SPLIT_BARRIER = 533,
    RESOURCE_BARRIER_UNMATCHED_END = 534,
    RESOURCE_BARRIER_UNMATCHED_BEGIN = 535,
    RESOURCE_BARRIER_INVALID_FLAG = 536,
    RESOURCE_BARRIER_INVALID_COMMAND_LIST_TYPE = 537,
    INVALID_SUBRESOURCE_STATE = 538,
    COMMAND_ALLOCATOR_CONTENTION = 540,
    COMMAND_ALLOCATOR_RESET = 541,
    COMMAND_ALLOCATOR_RESET_BUNDLE = 542,
    COMMAND_ALLOCATOR_CANNOT_RESET = 543,
    COMMAND_LIST_OPEN = 544,
    INVALID_BUNDLE_API = 546,
    COMMAND_LIST_CLOSED = 547,
    WRONG_COMMAND_ALLOCATOR_TYPE = 549,
    COMMAND_ALLOCATOR_SYNC = 552,
    COMMAND_LIST_SYNC = 553,
    SET_DESCRIPTOR_HEAP_INVALID = 554,
    CREATE_COMMANDQUEUE = 557,
    CREATE_COMMANDALLOCATOR = 558,
    CREATE_PIPELINESTATE = 559,
    CREATE_COMMANDLIST12 = 560,
    CREATE_RESOURCE = 562,
    CREATE_DESCRIPTORHEAP = 563,
    CREATE_ROOTSIGNATURE = 564,
    CREATE_LIBRARY = 565,
    CREATE_HEAP = 566,
    CREATE_MONITOREDFENCE = 567,
    CREATE_QUERYHEAP = 568,
    CREATE_COMMANDSIGNATURE = 569,
    LIVE_COMMANDQUEUE = 570,
    LIVE_COMMANDALLOCATOR = 571,
    LIVE_PIPELINESTATE = 572,
    LIVE_COMMANDLIST12 = 573,
    LIVE_RESOURCE = 575,
    LIVE_DESCRIPTORHEAP = 576,
    LIVE_ROOTSIGNATURE = 577,
    LIVE_LIBRARY = 578,
    LIVE_HEAP = 579,
    LIVE_MONITOREDFENCE = 580,
    LIVE_QUERYHEAP = 581,
    LIVE_COMMANDSIGNATURE = 582,
    DESTROY_COMMANDQUEUE = 583,
    DESTROY_COMMANDALLOCATOR = 584,
    DESTROY_PIPELINESTATE = 585,
    DESTROY_COMMANDLIST12 = 586,
    DESTROY_RESOURCE = 588,
    DESTROY_DESCRIPTORHEAP = 589,
    DESTROY_ROOTSIGNATURE = 590,
    DESTROY_LIBRARY = 591,
    DESTROY_HEAP = 592,
    DESTROY_MONITOREDFENCE = 593,
    DESTROY_QUERYHEAP = 594,
    DESTROY_COMMANDSIGNATURE = 595,
    CREATERESOURCE_INVALIDDIMENSIONS = 597,
    CREATERESOURCE_INVALIDMISCFLAGS = 599,
    CREATERESOURCE_INVALIDARG_RETURN = 602,
    CREATERESOURCE_OUTOFMEMORY_RETURN = 603,
    CREATERESOURCE_INVALIDDESC = 604,
    POSSIBLY_INVALID_SUBRESOURCE_STATE = 607,
    INVALID_USE_OF_NON_RESIDENT_RESOURCE = 608,
    POSSIBLE_INVALID_USE_OF_NON_RESIDENT_RESOURCE = 609,
    BUNDLE_PIPELINE_STATE_MISMATCH = 610,
    PRIMITIVE_TOPOLOGY_MISMATCH_PIPELINE_STATE = 611,
    RENDER_TARGET_FORMAT_MISMATCH_PIPELINE_STATE = 613,
    RENDER_TARGET_SAMPLE_DESC_MISMATCH_PIPELINE_STATE = 614,
    DEPTH_STENCIL_FORMAT_MISMATCH_PIPELINE_STATE = 615,
    DEPTH_STENCIL_SAMPLE_DESC_MISMATCH_PIPELINE_STATE = 616,
    CREATESHADER_INVALIDBYTECODE = 622,
    CREATEHEAP_NULLDESC = 623,
    CREATEHEAP_INVALIDSIZE = 624,
    CREATEHEAP_UNRECOGNIZEDHEAPTYPE = 625,
    CREATEHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES = 626,
    CREATEHEAP_UNRECOGNIZEDMEMORYPOOL = 627,
    CREATEHEAP_INVALIDPROPERTIES = 628,
    CREATEHEAP_INVALIDALIGNMENT = 629,
    CREATEHEAP_UNRECOGNIZEDMISCFLAGS = 630,
    CREATEHEAP_INVALIDMISCFLAGS = 631,
    CREATEHEAP_INVALIDARG_RETURN = 632,
    CREATEHEAP_OUTOFMEMORY_RETURN = 633,
    CREATERESOURCEANDHEAP_NULLHEAPPROPERTIES = 634,
    CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPTYPE = 635,
    CREATERESOURCEANDHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES = 636,
    CREATERESOURCEANDHEAP_UNRECOGNIZEDMEMORYPOOL = 637,
    CREATERESOURCEANDHEAP_INVALIDHEAPPROPERTIES = 638,
    CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPMISCFLAGS = 639,
    CREATERESOURCEANDHEAP_INVALIDHEAPMISCFLAGS = 640,
    CREATERESOURCEANDHEAP_INVALIDARG_RETURN = 641,
    CREATERESOURCEANDHEAP_OUTOFMEMORY_RETURN = 642,
    GETCUSTOMHEAPPROPERTIES_UNRECOGNIZEDHEAPTYPE = 643,
    GETCUSTOMHEAPPROPERTIES_INVALIDHEAPTYPE = 644,
    CREATE_DESCRIPTOR_HEAP_INVALID_DESC = 645,
    INVALID_DESCRIPTOR_HANDLE = 646,
    CREATERASTERIZERSTATE_INVALID_CONSERVATIVERASTERMODE = 647,
    CREATE_CONSTANT_BUFFER_VIEW_INVALID_RESOURCE = 649,
    CREATE_CONSTANT_BUFFER_VIEW_INVALID_DESC = 650,
    CREATE_UNORDEREDACCESS_VIEW_INVALID_COUNTER_USAGE = 652,
    COPY_DESCRIPTORS_INVALID_RANGES = 653,
    COPY_DESCRIPTORS_WRITE_ONLY_DESCRIPTOR = 654,
    CREATEGRAPHICSPIPELINESTATE_RTV_FORMAT_NOT_UNKNOWN = 655,
    CREATEGRAPHICSPIPELINESTATE_INVALID_RENDER_TARGET_COUNT = 656,
    CREATEGRAPHICSPIPELINESTATE_VERTEX_SHADER_NOT_SET = 657,
    CREATEGRAPHICSPIPELINESTATE_INPUTLAYOUT_NOT_SET = 658,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_HS_DS_SIGNATURE_MISMATCH = 659,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERINDEX = 660,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_COMPONENTTYPE = 661,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERMASK = 662,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SYSTEMVALUE = 663,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS = 664,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_MINPRECISION = 665,
    CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND = 666,
    CREATEGRAPHICSPIPELINESTATE_HS_XOR_DS_MISMATCH = 667,
    CREATEGRAPHICSPIPELINESTATE_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH = 668,
    CREATEGRAPHICSPIPELINESTATE_HS_DS_CONTROL_POINT_COUNT_MISMATCH = 669,
    CREATEGRAPHICSPIPELINESTATE_HS_DS_TESSELLATOR_DOMAIN_MISMATCH = 670,
    CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN = 671,
    CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_FORCED_SAMPLE_COUNT = 672,
    CREATEGRAPHICSPIPELINESTATE_INVALID_PRIMITIVETOPOLOGY = 673,
    CREATEGRAPHICSPIPELINESTATE_INVALID_SYSTEMVALUE = 674,
    CREATEGRAPHICSPIPELINESTATE_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 = 675,
    CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING = 676,
    CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_TYPE_MISMATCH = 677,
    CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS = 678,
    CREATEGRAPHICSPIPELINESTATE_RENDERTARGETVIEW_NOT_SET = 679,
    CREATEGRAPHICSPIPELINESTATE_DEPTHSTENCILVIEW_NOT_SET = 680,
    CREATEGRAPHICSPIPELINESTATE_GS_INPUT_PRIMITIVE_MISMATCH = 681,
    CREATEGRAPHICSPIPELINESTATE_POSITION_NOT_PRESENT = 682,
    CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE_FLAGS = 683,
    CREATEGRAPHICSPIPELINESTATE_INVALID_INDEX_BUFFER_PROPERTIES = 684,
    CREATEGRAPHICSPIPELINESTATE_INVALID_SAMPLE_DESC = 685,
    CREATEGRAPHICSPIPELINESTATE_HS_ROOT_SIGNATURE_MISMATCH = 686,
    CREATEGRAPHICSPIPELINESTATE_DS_ROOT_SIGNATURE_MISMATCH = 687,
    CREATEGRAPHICSPIPELINESTATE_VS_ROOT_SIGNATURE_MISMATCH = 688,
    CREATEGRAPHICSPIPELINESTATE_GS_ROOT_SIGNATURE_MISMATCH = 689,
    CREATEGRAPHICSPIPELINESTATE_PS_ROOT_SIGNATURE_MISMATCH = 690,
    CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE = 691,
    EXECUTE_BUNDLE_OPEN_BUNDLE = 692,
    EXECUTE_BUNDLE_DESCRIPTOR_HEAP_MISMATCH = 693,
    EXECUTE_BUNDLE_TYPE = 694,
    DRAW_EMPTY_SCISSOR_RECTANGLE = 695,
    CREATE_ROOT_SIGNATURE_BLOB_NOT_FOUND = 696,
    CREATE_ROOT_SIGNATURE_DESERIALIZE_FAILED = 697,
    CREATE_ROOT_SIGNATURE_INVALID_CONFIGURATION = 698,
    CREATE_ROOT_SIGNATURE_NOT_SUPPORTED_ON_DEVICE = 699,
    CREATERESOURCEANDHEAP_NULLRESOURCEPROPERTIES = 700,
    CREATERESOURCEANDHEAP_NULLHEAP = 701,
    GETRESOURCEALLOCATIONINFO_INVALIDRDESCS = 702,
    MAKERESIDENT_NULLOBJECTARRAY = 703,
    EVICT_NULLOBJECTARRAY = 705,
    SET_DESCRIPTOR_TABLE_INVALID = 708,
    SET_ROOT_CONSTANT_INVALID = 709,
    SET_ROOT_CONSTANT_BUFFER_VIEW_INVALID = 710,
    SET_ROOT_SHADER_RESOURCE_VIEW_INVALID = 711,
    SET_ROOT_UNORDERED_ACCESS_VIEW_INVALID = 712,
    SET_VERTEX_BUFFERS_INVALID_DESC = 713,
    SET_INDEX_BUFFER_INVALID_DESC = 715,
    SET_STREAM_OUTPUT_BUFFERS_INVALID_DESC = 717,
    CREATERESOURCE_UNRECOGNIZEDDIMENSIONALITY = 718,
    CREATERESOURCE_UNRECOGNIZEDLAYOUT = 719,
    CREATERESOURCE_INVALIDDIMENSIONALITY = 720,
    CREATERESOURCE_INVALIDALIGNMENT = 721,
    CREATERESOURCE_INVALIDMIPLEVELS = 722,
    CREATERESOURCE_INVALIDSAMPLEDESC = 723,
    CREATERESOURCE_INVALIDLAYOUT = 724,
    SET_INDEX_BUFFER_INVALID = 725,
    SET_VERTEX_BUFFERS_INVALID = 726,
    SET_STREAM_OUTPUT_BUFFERS_INVALID = 727,
    SET_RENDER_TARGETS_INVALID = 728,
    CREATEQUERY_HEAP_INVALID_PARAMETERS = 729,
    BEGIN_END_QUERY_INVALID_PARAMETERS = 731,
    CLOSE_COMMAND_LIST_OPEN_QUERY = 732,
    RESOLVE_QUERY_DATA_INVALID_PARAMETERS = 733,
    SET_PREDICATION_INVALID_PARAMETERS = 734,
    TIMESTAMPS_NOT_SUPPORTED = 735,
    CREATERESOURCE_UNRECOGNIZEDFORMAT = 737,
    CREATERESOURCE_INVALIDFORMAT = 738,
    // GETCOPYABLEFOOTPRINTS_INVALIDSUBRESOURCERANGE = 739,
    // GETCOPYABLEFOOTPRINTS_INVALIDBASEOFFSET = 740,
    GETCOPYABLELAYOUT_INVALIDSUBRESOURCERANGE = 739,
    GETCOPYABLELAYOUT_INVALIDBASEOFFSET = 740,
    RESOURCE_BARRIER_INVALID_HEAP = 741,
    CREATE_SAMPLER_INVALID = 742,
    CREATECOMMANDSIGNATURE_INVALID = 743,
    EXECUTE_INDIRECT_INVALID_PARAMETERS = 744,
    GETGPUVIRTUALADDRESS_INVALID_RESOURCE_DIMENSION = 745,
    CREATERESOURCE_INVALIDCLEARVALUE = 815,
    CREATERESOURCE_UNRECOGNIZEDCLEARVALUEFORMAT = 816,
    CREATERESOURCE_INVALIDCLEARVALUEFORMAT = 817,
    CREATERESOURCE_CLEARVALUEDENORMFLUSH = 818,
    CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE = 820,
    CLEARDEPTHSTENCILVIEW_MISMATCHINGCLEARVALUE = 821,
    MAP_INVALIDHEAP = 822,
    UNMAP_INVALIDHEAP = 823,
    MAP_INVALIDRESOURCE = 824,
    UNMAP_INVALIDRESOURCE = 825,
    MAP_INVALIDSUBRESOURCE = 826,
    UNMAP_INVALIDSUBRESOURCE = 827,
    MAP_INVALIDRANGE = 828,
    UNMAP_INVALIDRANGE = 829,
    MAP_INVALIDDATAPOINTER = 832,
    MAP_INVALIDARG_RETURN = 833,
    MAP_OUTOFMEMORY_RETURN = 834,
    EXECUTECOMMANDLISTS_BUNDLENOTSUPPORTED = 835,
    EXECUTECOMMANDLISTS_COMMANDLISTMISMATCH = 836,
    EXECUTECOMMANDLISTS_OPENCOMMANDLIST = 837,
    EXECUTECOMMANDLISTS_FAILEDCOMMANDLIST = 838,
    COPYBUFFERREGION_NULLDST = 839,
    COPYBUFFERREGION_INVALIDDSTRESOURCEDIMENSION = 840,
    COPYBUFFERREGION_DSTRANGEOUTOFBOUNDS = 841,
    COPYBUFFERREGION_NULLSRC = 842,
    COPYBUFFERREGION_INVALIDSRCRESOURCEDIMENSION = 843,
    COPYBUFFERREGION_SRCRANGEOUTOFBOUNDS = 844,
    COPYBUFFERREGION_INVALIDCOPYFLAGS = 845,
    COPYTEXTUREREGION_NULLDST = 846,
    COPYTEXTUREREGION_UNRECOGNIZEDDSTTYPE = 847,
    COPYTEXTUREREGION_INVALIDDSTRESOURCEDIMENSION = 848,
    COPYTEXTUREREGION_INVALIDDSTRESOURCE = 849,
    COPYTEXTUREREGION_INVALIDDSTSUBRESOURCE = 850,
    COPYTEXTUREREGION_INVALIDDSTOFFSET = 851,
    COPYTEXTUREREGION_UNRECOGNIZEDDSTFORMAT = 852,
    COPYTEXTUREREGION_INVALIDDSTFORMAT = 853,
    COPYTEXTUREREGION_INVALIDDSTDIMENSIONS = 854,
    COPYTEXTUREREGION_INVALIDDSTROWPITCH = 855,
    COPYTEXTUREREGION_INVALIDDSTPLACEMENT = 856,
    COPYTEXTUREREGION_INVALIDDSTDSPLACEDFOOTPRINTFORMAT = 857,
    COPYTEXTUREREGION_DSTREGIONOUTOFBOUNDS = 858,
    COPYTEXTUREREGION_NULLSRC = 859,
    COPYTEXTUREREGION_UNRECOGNIZEDSRCTYPE = 860,
    COPYTEXTUREREGION_INVALIDSRCRESOURCEDIMENSION = 861,
    COPYTEXTUREREGION_INVALIDSRCRESOURCE = 862,
    COPYTEXTUREREGION_INVALIDSRCSUBRESOURCE = 863,
    COPYTEXTUREREGION_INVALIDSRCOFFSET = 864,
    COPYTEXTUREREGION_UNRECOGNIZEDSRCFORMAT = 865,
    COPYTEXTUREREGION_INVALIDSRCFORMAT = 866,
    COPYTEXTUREREGION_INVALIDSRCDIMENSIONS = 867,
    COPYTEXTUREREGION_INVALIDSRCROWPITCH = 868,
    COPYTEXTUREREGION_INVALIDSRCPLACEMENT = 869,
    COPYTEXTUREREGION_INVALIDSRCDSPLACEDFOOTPRINTFORMAT = 870,
    COPYTEXTUREREGION_SRCREGIONOUTOFBOUNDS = 871,
    COPYTEXTUREREGION_INVALIDDSTCOORDINATES = 872,
    COPYTEXTUREREGION_INVALIDSRCBOX = 873,
    COPYTEXTUREREGION_FORMATMISMATCH = 874,
    COPYTEXTUREREGION_EMPTYBOX = 875,
    COPYTEXTUREREGION_INVALIDCOPYFLAGS = 876,
    RESOLVESUBRESOURCE_INVALID_SUBRESOURCE_INDEX = 877,
    RESOLVESUBRESOURCE_INVALID_FORMAT = 878,
    RESOLVESUBRESOURCE_RESOURCE_MISMATCH = 879,
    RESOLVESUBRESOURCE_INVALID_SAMPLE_COUNT = 880,
    CREATECOMPUTEPIPELINESTATE_INVALID_SHADER = 881,
    CREATECOMPUTEPIPELINESTATE_CS_ROOT_SIGNATURE_MISMATCH = 882,
    CREATECOMPUTEPIPELINESTATE_MISSING_ROOT_SIGNATURE = 883,
    CREATEPIPELINESTATE_INVALIDCACHEDBLOB = 884,
    CREATEPIPELINESTATE_CACHEDBLOBADAPTERMISMATCH = 885,
    CREATEPIPELINESTATE_CACHEDBLOBDRIVERVERSIONMISMATCH = 886,
    CREATEPIPELINESTATE_CACHEDBLOBDESCMISMATCH = 887,
    CREATEPIPELINESTATE_CACHEDBLOBIGNORED = 888,
    WRITETOSUBRESOURCE_INVALIDHEAP = 889,
    WRITETOSUBRESOURCE_INVALIDRESOURCE = 890,
    WRITETOSUBRESOURCE_INVALIDBOX = 891,
    WRITETOSUBRESOURCE_INVALIDSUBRESOURCE = 892,
    WRITETOSUBRESOURCE_EMPTYBOX = 893,
    READFROMSUBRESOURCE_INVALIDHEAP = 894,
    READFROMSUBRESOURCE_INVALIDRESOURCE = 895,
    READFROMSUBRESOURCE_INVALIDBOX = 896,
    READFROMSUBRESOURCE_INVALIDSUBRESOURCE = 897,
    READFROMSUBRESOURCE_EMPTYBOX = 898,
    TOO_MANY_NODES_SPECIFIED = 899,
    INVALID_NODE_INDEX = 900,
    GETHEAPPROPERTIES_INVALIDRESOURCE = 901,
    NODE_MASK_MISMATCH = 902,
    COMMAND_LIST_OUTOFMEMORY = 903,
    COMMAND_LIST_MULTIPLE_SWAPCHAIN_BUFFER_REFERENCES = 904,
    COMMAND_LIST_TOO_MANY_SWAPCHAIN_REFERENCES = 905,
    COMMAND_QUEUE_TOO_MANY_SWAPCHAIN_REFERENCES = 906,
    EXECUTECOMMANDLISTS_WRONGSWAPCHAINBUFFERREFERENCE = 907,
    COMMAND_LIST_SETRENDERTARGETS_INVALIDNUMRENDERTARGETS = 908,
    CREATE_QUEUE_INVALID_TYPE = 909,
    CREATE_QUEUE_INVALID_FLAGS = 910,
    CREATESHAREDRESOURCE_INVALIDFLAGS = 911,
    CREATESHAREDRESOURCE_INVALIDFORMAT = 912,
    CREATESHAREDHEAP_INVALIDFLAGS = 913,
    REFLECTSHAREDPROPERTIES_UNRECOGNIZEDPROPERTIES = 914,
    REFLECTSHAREDPROPERTIES_INVALIDSIZE = 915,
    REFLECTSHAREDPROPERTIES_INVALIDOBJECT = 916,
    KEYEDMUTEX_INVALIDOBJECT = 917,
    KEYEDMUTEX_INVALIDKEY = 918,
    KEYEDMUTEX_WRONGSTATE = 919,
    CREATE_QUEUE_INVALID_PRIORITY = 920,
    OBJECT_DELETED_WHILE_STILL_IN_USE = 921,
    CREATEPIPELINESTATE_INVALID_FLAGS = 922,
    HEAP_ADDRESS_RANGE_HAS_NO_RESOURCE = 923,
    COMMAND_LIST_DRAW_RENDER_TARGET_DELETED = 924,
    CREATEGRAPHICSPIPELINESTATE_ALL_RENDER_TARGETS_HAVE_UNKNOWN_FORMAT = 925,
    HEAP_ADDRESS_RANGE_INTERSECTS_MULTIPLE_BUFFERS = 926,
    EXECUTECOMMANDLISTS_GPU_WRITTEN_READBACK_RESOURCE_MAPPED = 927,
    UNMAP_RANGE_NOT_EMPTY = 929,
    MAP_INVALID_NULLRANGE = 930,
    UNMAP_INVALID_NULLRANGE = 931,
    NO_GRAPHICS_API_SUPPORT = 932,
    NO_COMPUTE_API_SUPPORT = 933,
    RESOLVESUBRESOURCE_RESOURCE_FLAGS_NOT_SUPPORTED = 934,
    GPU_BASED_VALIDATION_ROOT_ARGUMENT_UNINITIALIZED = 935,
    GPU_BASED_VALIDATION_DESCRIPTOR_HEAP_INDEX_OUT_OF_BOUNDS = 936,
    GPU_BASED_VALIDATION_DESCRIPTOR_TABLE_REGISTER_INDEX_OUT_OF_BOUNDS = 937,
    GPU_BASED_VALIDATION_DESCRIPTOR_UNINITIALIZED = 938,
    GPU_BASED_VALIDATION_DESCRIPTOR_TYPE_MISMATCH = 939,
    GPU_BASED_VALIDATION_SRV_RESOURCE_DIMENSION_MISMATCH = 940,
    GPU_BASED_VALIDATION_UAV_RESOURCE_DIMENSION_MISMATCH = 941,
    GPU_BASED_VALIDATION_INCOMPATIBLE_RESOURCE_STATE = 942,
    COPYRESOURCE_NULLDST = 943,
    COPYRESOURCE_INVALIDDSTRESOURCE = 944,
    COPYRESOURCE_NULLSRC = 945,
    COPYRESOURCE_INVALIDSRCRESOURCE = 946,
    RESOLVESUBRESOURCE_NULLDST = 947,
    RESOLVESUBRESOURCE_INVALIDDSTRESOURCE = 948,
    RESOLVESUBRESOURCE_NULLSRC = 949,
    RESOLVESUBRESOURCE_INVALIDSRCRESOURCE = 950,
    PIPELINE_STATE_TYPE_MISMATCH = 951,
    COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_NOT_SET = 952,
    COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_MISMATCH = 953,
    RESOURCE_BARRIER_ZERO_BARRIERS = 954,
    BEGIN_END_EVENT_MISMATCH = 955,
    RESOURCE_BARRIER_POSSIBLE_BEFORE_AFTER_MISMATCH = 956,
    RESOURCE_BARRIER_MISMATCHING_BEGIN_END = 957,
    GPU_BASED_VALIDATION_INVALID_RESOURCE = 958,
    USE_OF_ZERO_REFCOUNT_OBJECT = 959,
    OBJECT_EVICTED_WHILE_STILL_IN_USE = 960,
    GPU_BASED_VALIDATION_ROOT_DESCRIPTOR_ACCESS_OUT_OF_BOUNDS = 961,
    CREATEPIPELINELIBRARY_INVALIDLIBRARYBLOB = 962,
    CREATEPIPELINELIBRARY_DRIVERVERSIONMISMATCH = 963,
    CREATEPIPELINELIBRARY_ADAPTERVERSIONMISMATCH = 964,
    CREATEPIPELINELIBRARY_UNSUPPORTED = 965,
    CREATE_PIPELINELIBRARY = 966,
    LIVE_PIPELINELIBRARY = 967,
    DESTROY_PIPELINELIBRARY = 968,
    STOREPIPELINE_NONAME = 969,
    STOREPIPELINE_DUPLICATENAME = 970,
    LOADPIPELINE_NAMENOTFOUND = 971,
    LOADPIPELINE_INVALIDDESC = 972,
    PIPELINELIBRARY_SERIALIZE_NOTENOUGHMEMORY = 973,
    CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_RT_OUTPUT_MISMATCH = 974,
    SETEVENTONMULTIPLEFENCECOMPLETION_INVALIDFLAGS = 975,
    CREATE_QUEUE_VIDEO_NOT_SUPPORTED = 976,
    CREATE_COMMAND_ALLOCATOR_VIDEO_NOT_SUPPORTED = 977,
    CREATEQUERY_HEAP_VIDEO_DECODE_STATISTICS_NOT_SUPPORTED = 978,
    CREATE_VIDEODECODECOMMANDLIST = 979,
    CREATE_VIDEODECODER = 980,
    CREATE_VIDEODECODESTREAM = 981,
    LIVE_VIDEODECODECOMMANDLIST = 982,
    LIVE_VIDEODECODER = 983,
    LIVE_VIDEODECODESTREAM = 984,
    DESTROY_VIDEODECODECOMMANDLIST = 985,
    DESTROY_VIDEODECODER = 986,
    DESTROY_VIDEODECODESTREAM = 987,
    DECODE_FRAME_INVALID_PARAMETERS = 988,
    DEPRECATED_API = 989,
    RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE = 990,
    COMMAND_LIST_DESCRIPTOR_TABLE_NOT_SET = 991,
    COMMAND_LIST_ROOT_CONSTANT_BUFFER_VIEW_NOT_SET = 992,
    COMMAND_LIST_ROOT_SHADER_RESOURCE_VIEW_NOT_SET = 993,
    COMMAND_LIST_ROOT_UNORDERED_ACCESS_VIEW_NOT_SET = 994,
    DISCARD_INVALID_SUBRESOURCE_RANGE = 995,
    DISCARD_ONE_SUBRESOURCE_FOR_MIPS_WITH_RECTS = 996,
    DISCARD_NO_RECTS_FOR_NON_TEXTURE2D = 997,
    COPY_ON_SAME_SUBRESOURCE = 998,
    SETRESIDENCYPRIORITY_INVALID_PAGEABLE = 999,
    GPU_BASED_VALIDATION_UNSUPPORTED = 1000,
    STATIC_DESCRIPTOR_INVALID_DESCRIPTOR_CHANGE = 1001,
    DATA_STATIC_DESCRIPTOR_INVALID_DATA_CHANGE = 1002,
    DATA_STATIC_WHILE_SET_AT_EXECUTE_DESCRIPTOR_INVALID_DATA_CHANGE = 1003,
    EXECUTE_BUNDLE_STATIC_DESCRIPTOR_DATA_STATIC_NOT_SET = 1004,
    GPU_BASED_VALIDATION_RESOURCE_ACCESS_OUT_OF_BOUNDS = 1005,
    GPU_BASED_VALIDATION_SAMPLER_MODE_MISMATCH = 1006,
    CREATE_FENCE_INVALID_FLAGS = 1007,
    RESOURCE_BARRIER_DUPLICATE_SUBRESOURCE_TRANSITIONS = 1008,
    SETRESIDENCYPRIORITY_INVALID_PRIORITY = 1009,
    CREATE_DESCRIPTOR_HEAP_LARGE_NUM_DESCRIPTORS = 1013,
    BEGIN_EVENT = 1014,
    END_EVENT = 1015,
    CREATEDEVICE_DEBUG_LAYER_STARTUP_OPTIONS = 1016,
    CREATEDEPTHSTENCILSTATE_DEPTHBOUNDSTEST_UNSUPPORTED = 1017,
    CREATEPIPELINESTATE_DUPLICATE_SUBOBJECT = 1018,
    CREATEPIPELINESTATE_UNKNOWN_SUBOBJECT = 1019,
    CREATEPIPELINESTATE_ZERO_SIZE_STREAM = 1020,
    CREATEPIPELINESTATE_INVALID_STREAM = 1021,
    CREATEPIPELINESTATE_CANNOT_DEDUCE_TYPE = 1022,
    COMMAND_LIST_STATIC_DESCRIPTOR_RESOURCE_DIMENSION_MISMATCH = 1023,
    CREATE_COMMAND_QUEUE_INSUFFICIENT_PRIVILEGE_FOR_GLOBAL_REALTIME = 1024,
    CREATE_COMMAND_QUEUE_INSUFFICIENT_HARDWARE_SUPPORT_FOR_GLOBAL_REALTIME = 1025,
    ATOMICCOPYBUFFER_INVALID_ARCHITECTURE = 1026,
    ATOMICCOPYBUFFER_NULL_DST = 1027,
    ATOMICCOPYBUFFER_INVALID_DST_RESOURCE_DIMENSION = 1028,
    ATOMICCOPYBUFFER_DST_RANGE_OUT_OF_BOUNDS = 1029,
    ATOMICCOPYBUFFER_NULL_SRC = 1030,
    ATOMICCOPYBUFFER_INVALID_SRC_RESOURCE_DIMENSION = 1031,
    ATOMICCOPYBUFFER_SRC_RANGE_OUT_OF_BOUNDS = 1032,
    ATOMICCOPYBUFFER_INVALID_OFFSET_ALIGNMENT = 1033,
    ATOMICCOPYBUFFER_NULL_DEPENDENT_RESOURCES = 1034,
    ATOMICCOPYBUFFER_NULL_DEPENDENT_SUBRESOURCE_RANGES = 1035,
    ATOMICCOPYBUFFER_INVALID_DEPENDENT_RESOURCE = 1036,
    ATOMICCOPYBUFFER_INVALID_DEPENDENT_SUBRESOURCE_RANGE = 1037,
    ATOMICCOPYBUFFER_DEPENDENT_SUBRESOURCE_OUT_OF_BOUNDS = 1038,
    ATOMICCOPYBUFFER_DEPENDENT_RANGE_OUT_OF_BOUNDS = 1039,
    ATOMICCOPYBUFFER_ZERO_DEPENDENCIES = 1040,
    DEVICE_CREATE_SHARED_HANDLE_INVALIDARG = 1041,
    DESCRIPTOR_HANDLE_WITH_INVALID_RESOURCE = 1042,
    SETDEPTHBOUNDS_INVALIDARGS = 1043,
    GPU_BASED_VALIDATION_RESOURCE_STATE_IMPRECISE = 1044,
    COMMAND_LIST_PIPELINE_STATE_NOT_SET = 1045,
    CREATEGRAPHICSPIPELINESTATE_SHADER_MODEL_MISMATCH = 1046,
    OBJECT_ACCESSED_WHILE_STILL_IN_USE = 1047,
    PROGRAMMABLE_MSAA_UNSUPPORTED = 1048,
    SETSAMPLEPOSITIONS_INVALIDARGS = 1049,
    RESOLVESUBRESOURCEREGION_INVALID_RECT = 1050,
    CREATE_VIDEODECODECOMMANDQUEUE = 1051,
    CREATE_VIDEOPROCESSCOMMANDLIST = 1052,
    CREATE_VIDEOPROCESSCOMMANDQUEUE = 1053,
    LIVE_VIDEODECODECOMMANDQUEUE = 1054,
    LIVE_VIDEOPROCESSCOMMANDLIST = 1055,
    LIVE_VIDEOPROCESSCOMMANDQUEUE = 1056,
    DESTROY_VIDEODECODECOMMANDQUEUE = 1057,
    DESTROY_VIDEOPROCESSCOMMANDLIST = 1058,
    DESTROY_VIDEOPROCESSCOMMANDQUEUE = 1059,
    CREATE_VIDEOPROCESSOR = 1060,
    CREATE_VIDEOPROCESSSTREAM = 1061,
    LIVE_VIDEOPROCESSOR = 1062,
    LIVE_VIDEOPROCESSSTREAM = 1063,
    DESTROY_VIDEOPROCESSOR = 1064,
    DESTROY_VIDEOPROCESSSTREAM = 1065,
    PROCESS_FRAME_INVALID_PARAMETERS = 1066,
    COPY_INVALIDLAYOUT = 1067,
    CREATE_CRYPTO_SESSION = 1068,
    CREATE_CRYPTO_SESSION_POLICY = 1069,
    CREATE_PROTECTED_RESOURCE_SESSION = 1070,
    LIVE_CRYPTO_SESSION = 1071,
    LIVE_CRYPTO_SESSION_POLICY = 1072,
    LIVE_PROTECTED_RESOURCE_SESSION = 1073,
    DESTROY_CRYPTO_SESSION = 1074,
    DESTROY_CRYPTO_SESSION_POLICY = 1075,
    DESTROY_PROTECTED_RESOURCE_SESSION = 1076,
    PROTECTED_RESOURCE_SESSION_UNSUPPORTED = 1077,
    FENCE_INVALIDOPERATION = 1078,
    CREATEQUERY_HEAP_COPY_QUEUE_TIMESTAMPS_NOT_SUPPORTED = 1079,
    SAMPLEPOSITIONS_MISMATCH_DEFERRED = 1080,
    SAMPLEPOSITIONS_MISMATCH_RECORDTIME_ASSUMEDFROMFIRSTUSE = 1081,
    SAMPLEPOSITIONS_MISMATCH_RECORDTIME_ASSUMEDFROMCLEAR = 1082,
    CREATE_VIDEODECODERHEAP = 1083,
    LIVE_VIDEODECODERHEAP = 1084,
    DESTROY_VIDEODECODERHEAP = 1085,
    OPENEXISTINGHEAP_INVALIDARG_RETURN = 1086,
    OPENEXISTINGHEAP_OUTOFMEMORY_RETURN = 1087,
    OPENEXISTINGHEAP_INVALIDADDRESS = 1088,
    OPENEXISTINGHEAP_INVALIDHANDLE = 1089,
    WRITEBUFFERIMMEDIATE_INVALID_DEST = 1090,
    WRITEBUFFERIMMEDIATE_INVALID_MODE = 1091,
    WRITEBUFFERIMMEDIATE_INVALID_ALIGNMENT = 1092,
    WRITEBUFFERIMMEDIATE_NOT_SUPPORTED = 1093,
    SETVIEWINSTANCEMASK_INVALIDARGS = 1094,
    VIEW_INSTANCING_UNSUPPORTED = 1095,
    VIEW_INSTANCING_INVALIDARGS = 1096,
    COPYTEXTUREREGION_MISMATCH_DECODE_REFERENCE_ONLY_FLAG = 1097,
    COPYRESOURCE_MISMATCH_DECODE_REFERENCE_ONLY_FLAG = 1098,
    CREATE_VIDEO_DECODE_HEAP_CAPS_FAILURE = 1099,
    CREATE_VIDEO_DECODE_HEAP_CAPS_UNSUPPORTED = 1100,
    VIDEO_DECODE_SUPPORT_INVALID_INPUT = 1101,
    CREATE_VIDEO_DECODER_UNSUPPORTED = 1102,
    CREATEGRAPHICSPIPELINESTATE_METADATA_ERROR = 1103,
    CREATEGRAPHICSPIPELINESTATE_VIEW_INSTANCING_VERTEX_SIZE_EXCEEDED = 1104,
    CREATEGRAPHICSPIPELINESTATE_RUNTIME_INTERNAL_ERROR = 1105,
    NO_VIDEO_API_SUPPORT = 1106,
    VIDEO_PROCESS_SUPPORT_INVALID_INPUT = 1107,
    CREATE_VIDEO_PROCESSOR_CAPS_FAILURE = 1108,
    VIDEO_PROCESS_SUPPORT_UNSUPPORTED_FORMAT = 1109,
    VIDEO_DECODE_FRAME_INVALID_ARGUMENT = 1110,
    ENQUEUE_MAKE_RESIDENT_INVALID_FLAGS = 1111,
    OPENEXISTINGHEAP_UNSUPPORTED = 1112,
    VIDEO_PROCESS_FRAMES_INVALID_ARGUMENT = 1113,
    VIDEO_DECODE_SUPPORT_UNSUPPORTED = 1114,
    CREATE_COMMANDRECORDER = 1115,
    LIVE_COMMANDRECORDER = 1116,
    DESTROY_COMMANDRECORDER = 1117,
    CREATE_COMMAND_RECORDER_VIDEO_NOT_SUPPORTED = 1118,
    CREATE_COMMAND_RECORDER_INVALID_SUPPORT_FLAGS = 1119,
    CREATE_COMMAND_RECORDER_INVALID_FLAGS = 1120,
    CREATE_COMMAND_RECORDER_MORE_RECORDERS_THAN_LOGICAL_PROCESSORS = 1121,
    CREATE_COMMANDPOOL = 1122,
    LIVE_COMMANDPOOL = 1123,
    DESTROY_COMMANDPOOL = 1124,
    CREATE_COMMAND_POOL_INVALID_FLAGS = 1125,
    CREATE_COMMAND_LIST_VIDEO_NOT_SUPPORTED = 1126,
    COMMAND_RECORDER_SUPPORT_FLAGS_MISMATCH = 1127,
    COMMAND_RECORDER_CONTENTION = 1128,
    COMMAND_RECORDER_USAGE_WITH_CREATECOMMANDLIST_COMMAND_LIST = 1129,
    COMMAND_ALLOCATOR_USAGE_WITH_CREATECOMMANDLIST1_COMMAND_LIST = 1130,
    CANNOT_EXECUTE_EMPTY_COMMAND_LIST = 1131,
    CANNOT_RESET_COMMAND_POOL_WITH_OPEN_COMMAND_LISTS = 1132,
    CANNOT_USE_COMMAND_RECORDER_WITHOUT_CURRENT_TARGET = 1133,
    CANNOT_CHANGE_COMMAND_RECORDER_TARGET_WHILE_RECORDING = 1134,
    COMMAND_POOL_SYNC = 1135,
    EVICT_UNDERFLOW = 1136,
    CREATE_META_COMMAND = 1137,
    LIVE_META_COMMAND = 1138,
    DESTROY_META_COMMAND = 1139,
    COPYBUFFERREGION_INVALID_DST_RESOURCE = 1140,
    COPYBUFFERREGION_INVALID_SRC_RESOURCE = 1141,
    ATOMICCOPYBUFFER_INVALID_DST_RESOURCE = 1142,
    ATOMICCOPYBUFFER_INVALID_SRC_RESOURCE = 1143,
    CREATEPLACEDRESOURCEONBUFFER_NULL_BUFFER = 1144,
    CREATEPLACEDRESOURCEONBUFFER_NULL_RESOURCE_DESC = 1145,
    CREATEPLACEDRESOURCEONBUFFER_UNSUPPORTED = 1146,
    CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_DIMENSION = 1147,
    CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_FLAGS = 1148,
    CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_OFFSET = 1149,
    CREATEPLACEDRESOURCEONBUFFER_INVALID_RESOURCE_DIMENSION = 1150,
    CREATEPLACEDRESOURCEONBUFFER_INVALID_RESOURCE_FLAGS = 1151,
    CREATEPLACEDRESOURCEONBUFFER_OUTOFMEMORY_RETURN = 1152,
    CANNOT_CREATE_GRAPHICS_AND_VIDEO_COMMAND_RECORDER = 1153,
    UPDATETILEMAPPINGS_POSSIBLY_MISMATCHING_PROPERTIES = 1154,
    CREATE_COMMAND_LIST_INVALID_COMMAND_LIST_TYPE = 1155,
    CLEARUNORDEREDACCESSVIEW_INCOMPATIBLE_WITH_STRUCTURED_BUFFERS = 1156,
    COMPUTE_ONLY_DEVICE_OPERATION_UNSUPPORTED = 1157,
    BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INVALID = 1158,
    EMIT_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_INVALID = 1159,
    COPY_RAYTRACING_ACCELERATION_STRUCTURE_INVALID = 1160,
    DISPATCH_RAYS_INVALID = 1161,
    GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_INVALID = 1162,
    CREATE_LIFETIMETRACKER = 1163,
    LIVE_LIFETIMETRACKER = 1164,
    DESTROY_LIFETIMETRACKER = 1165,
    DESTROYOWNEDOBJECT_OBJECTNOTOWNED = 1166,
    CREATE_TRACKEDWORKLOAD = 1167,
    LIVE_TRACKEDWORKLOAD = 1168,
    DESTROY_TRACKEDWORKLOAD = 1169,
    RENDER_PASS_ERROR = 1170,
    META_COMMAND_ID_INVALID = 1171,
    META_COMMAND_UNSUPPORTED_PARAMS = 1172,
    META_COMMAND_FAILED_ENUMERATION = 1173,
    META_COMMAND_PARAMETER_SIZE_MISMATCH = 1174,
    UNINITIALIZED_META_COMMAND = 1175,
    META_COMMAND_INVALID_GPU_VIRTUAL_ADDRESS = 1176,
    CREATE_VIDEOENCODECOMMANDLIST = 1177,
    LIVE_VIDEOENCODECOMMANDLIST = 1178,
    DESTROY_VIDEOENCODECOMMANDLIST = 1179,
    CREATE_VIDEOENCODECOMMANDQUEUE = 1180,
    LIVE_VIDEOENCODECOMMANDQUEUE = 1181,
    DESTROY_VIDEOENCODECOMMANDQUEUE = 1182,
    CREATE_VIDEOMOTIONESTIMATOR = 1183,
    LIVE_VIDEOMOTIONESTIMATOR = 1184,
    DESTROY_VIDEOMOTIONESTIMATOR = 1185,
    CREATE_VIDEOMOTIONVECTORHEAP = 1186,
    LIVE_VIDEOMOTIONVECTORHEAP = 1187,
    DESTROY_VIDEOMOTIONVECTORHEAP = 1188,
    MULTIPLE_TRACKED_WORKLOADS = 1189,
    MULTIPLE_TRACKED_WORKLOAD_PAIRS = 1190,
    OUT_OF_ORDER_TRACKED_WORKLOAD_PAIR = 1191,
    CANNOT_ADD_TRACKED_WORKLOAD = 1192,
    INCOMPLETE_TRACKED_WORKLOAD_PAIR = 1193,
    CREATE_STATE_OBJECT_ERROR = 1194,
    GET_SHADER_IDENTIFIER_ERROR = 1195,
    GET_SHADER_STACK_SIZE_ERROR = 1196,
    GET_PIPELINE_STACK_SIZE_ERROR = 1197,
    SET_PIPELINE_STACK_SIZE_ERROR = 1198,
    GET_SHADER_IDENTIFIER_SIZE_INVALID = 1199,
    CHECK_DRIVER_MATCHING_IDENTIFIER_INVALID = 1200,
    CHECK_DRIVER_MATCHING_IDENTIFIER_DRIVER_REPORTED_ISSUE = 1201,
    RENDER_PASS_INVALID_RESOURCE_BARRIER = 1202,
    RENDER_PASS_DISALLOWED_API_CALLED = 1203,
    RENDER_PASS_CANNOT_NEST_RENDER_PASSES = 1204,
    RENDER_PASS_CANNOT_END_WITHOUT_BEGIN = 1205,
    RENDER_PASS_CANNOT_CLOSE_COMMAND_LIST = 1206,
    RENDER_PASS_GPU_WORK_WHILE_SUSPENDED = 1207,
    RENDER_PASS_MISMATCHING_SUSPEND_RESUME = 1208,
    RENDER_PASS_NO_PRIOR_SUSPEND_WITHIN_EXECUTECOMMANDLISTS = 1209,
    RENDER_PASS_NO_SUBSEQUENT_RESUME_WITHIN_EXECUTECOMMANDLISTS = 1210,
    TRACKED_WORKLOAD_COMMAND_QUEUE_MISMATCH = 1211,
    TRACKED_WORKLOAD_NOT_SUPPORTED = 1212,
    RENDER_PASS_MISMATCHING_NO_ACCESS = 1213,
    RENDER_PASS_UNSUPPORTED_RESOLVE = 1214,
    CLEARUNORDEREDACCESSVIEW_INVALID_RESOURCE_PTR = 1215,
    WINDOWS7_FENCE_OUTOFORDER_SIGNAL = 1216,
    WINDOWS7_FENCE_OUTOFORDER_WAIT = 1217,
    VIDEO_CREATE_MOTION_ESTIMATOR_INVALID_ARGUMENT = 1218,
    VIDEO_CREATE_MOTION_VECTOR_HEAP_INVALID_ARGUMENT = 1219,
    ESTIMATE_MOTION_INVALID_ARGUMENT = 1220,
    RESOLVE_MOTION_VECTOR_HEAP_INVALID_ARGUMENT = 1221,
    GETGPUVIRTUALADDRESS_INVALID_HEAP_TYPE = 1222,
    SET_BACKGROUND_PROCESSING_MODE_INVALID_ARGUMENT = 1223,
    CREATE_COMMAND_LIST_INVALID_COMMAND_LIST_TYPE_FOR_FEATURE_LEVEL = 1224,
    CREATE_VIDEOEXTENSIONCOMMAND = 1225,
    LIVE_VIDEOEXTENSIONCOMMAND = 1226,
    DESTROY_VIDEOEXTENSIONCOMMAND = 1227,
    INVALID_VIDEO_EXTENSION_COMMAND_ID = 1228,
    VIDEO_EXTENSION_COMMAND_INVALID_ARGUMENT = 1229,
    CREATE_ROOT_SIGNATURE_NOT_UNIQUE_IN_DXIL_LIBRARY = 1230,
    VARIABLE_SHADING_RATE_NOT_ALLOWED_WITH_TIR = 1231,
    GEOMETRY_SHADER_OUTPUTTING_BOTH_VIEWPORT_ARRAY_INDEX_AND_SHADING_RATE_NOT_SUPPORTED_ON_DEVICE = 1232,
    RSSETSHADING_RATE_INVALID_SHADING_RATE = 1233,
    RSSETSHADING_RATE_SHADING_RATE_NOT_PERMITTED_BY_CAP = 1234,
    RSSETSHADING_RATE_INVALID_COMBINER = 1235,
    RSSETSHADINGRATEIMAGE_REQUIRES_TIER_2 = 1236,
    RSSETSHADINGRATE_REQUIRES_TIER_1 = 1237,
    SHADING_RATE_IMAGE_INCORRECT_FORMAT = 1238,
    SHADING_RATE_IMAGE_INCORRECT_ARRAY_SIZE = 1239,
    SHADING_RATE_IMAGE_INCORRECT_MIP_LEVEL = 1240,
    SHADING_RATE_IMAGE_INCORRECT_SAMPLE_COUNT = 1241,
    SHADING_RATE_IMAGE_INCORRECT_SAMPLE_QUALITY = 1242,
    NON_RETAIL_SHADER_MODEL_WONT_VALIDATE = 1243,
    CREATEGRAPHICSPIPELINESTATE_AS_ROOT_SIGNATURE_MISMATCH = 1244,
    CREATEGRAPHICSPIPELINESTATE_MS_ROOT_SIGNATURE_MISMATCH = 1245,
    ADD_TO_STATE_OBJECT_ERROR = 1246,
    CREATE_PROTECTED_RESOURCE_SESSION_INVALID_ARGUMENT = 1247,
    CREATEGRAPHICSPIPELINESTATE_MS_PSO_DESC_MISMATCH = 1248,
    CREATEPIPELINESTATE_MS_INCOMPLETE_TYPE = 1249,
    CREATEGRAPHICSPIPELINESTATE_AS_NOT_MS_MISMATCH = 1250,
    CREATEGRAPHICSPIPELINESTATE_MS_NOT_PS_MISMATCH = 1251,
    NONZERO_SAMPLER_FEEDBACK_MIP_REGION_WITH_INCOMPATIBLE_FORMAT = 1252,
    CREATEGRAPHICSPIPELINESTATE_INPUTLAYOUT_SHADER_MISMATCH = 1253,
    EMPTY_DISPATCH = 1254,
    RESOURCE_FORMAT_REQUIRES_SAMPLER_FEEDBACK_CAPABILITY = 1255,
    SAMPLER_FEEDBACK_MAP_INVALID_MIP_REGION = 1256,
    SAMPLER_FEEDBACK_MAP_INVALID_DIMENSION = 1257,
    SAMPLER_FEEDBACK_MAP_INVALID_SAMPLE_COUNT = 1258,
    SAMPLER_FEEDBACK_MAP_INVALID_SAMPLE_QUALITY = 1259,
    SAMPLER_FEEDBACK_MAP_INVALID_LAYOUT = 1260,
    SAMPLER_FEEDBACK_MAP_REQUIRES_UNORDERED_ACCESS_FLAG = 1261,
    SAMPLER_FEEDBACK_CREATE_UAV_NULL_ARGUMENTS = 1262,
    SAMPLER_FEEDBACK_UAV_REQUIRES_SAMPLER_FEEDBACK_CAPABILITY = 1263,
    SAMPLER_FEEDBACK_CREATE_UAV_REQUIRES_FEEDBACK_MAP_FORMAT = 1264,
    CREATEMESHSHADER_INVALIDSHADERBYTECODE = 1265,
    CREATEMESHSHADER_OUTOFMEMORY = 1266,
    CREATEMESHSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE = 1267,
    RESOLVESUBRESOURCE_SAMPLER_FEEDBACK_TRANSCODE_INVALID_FORMAT = 1268,
    RESOLVESUBRESOURCE_SAMPLER_FEEDBACK_INVALID_MIP_LEVEL_COUNT = 1269,
    RESOLVESUBRESOURCE_SAMPLER_FEEDBACK_TRANSCODE_ARRAY_SIZE_MISMATCH = 1270,
    SAMPLER_FEEDBACK_CREATE_UAV_MISMATCHING_TARGETED_RESOURCE = 1271,
    CREATEMESHSHADER_OUTPUTEXCEEDSMAXSIZE = 1272,
    CREATEMESHSHADER_GROUPSHAREDEXCEEDSMAXSIZE = 1273,
    VERTEX_SHADER_OUTPUTTING_BOTH_VIEWPORT_ARRAY_INDEX_AND_SHADING_RATE_NOT_SUPPORTED_ON_DEVICE = 1274,
    MESH_SHADER_OUTPUTTING_BOTH_VIEWPORT_ARRAY_INDEX_AND_SHADING_RATE_NOT_SUPPORTED_ON_DEVICE = 1275,
    CREATEMESHSHADER_MISMATCHEDASMSPAYLOADSIZE = 1276,
    CREATE_ROOT_SIGNATURE_UNBOUNDED_STATIC_DESCRIPTORS = 1277,
    CREATEAMPLIFICATIONSHADER_INVALIDSHADERBYTECODE = 1278,
    CREATEAMPLIFICATIONSHADER_OUTOFMEMORY = 1279,
    MESSAGES_END = 1280,
    CREATERESOURCE_STATE_IGNORED = 1328,
};

pub const MESSAGE = extern struct {
    Category: MESSAGE_CATEGORY,
    Severity: MESSAGE_SEVERITY,
    ID: MESSAGE_ID,
    pDescription: [*c]const u8,
    DescriptionByteLength: u32,
};

pub const INFO_QUEUE_FILTER_DESC = extern struct {
    NumCategories: u32 = 0,
    pCategoryList: ?[*]MESSAGE_CATEGORY = null,
    NumSeverities: u32 = 0,
    pSeverityList: ?[*]MESSAGE_SEVERITY = null,
    NumIDs: u32 = 0,
    pIDList: ?[*]MESSAGE_ID = null,
};

pub const INFO_QUEUE_FILTER = extern struct {
    AllowList: INFO_QUEUE_FILTER_DESC,
    DenyList: INFO_QUEUE_FILTER_DESC,
};

pub const MESSAGE_CALLBACK_FLAGS = packed struct(u32) {
    IGNORE_FILTERS: bool = false,
    _: u31 = 0,
};

pub const SHADER_BYTECODE = extern struct {
    pShaderBytecode: ?*const anyopaque = null,
    BytecodeLength: UINT64 = 0,
};

pub const SO_DECLARATION_ENTRY = extern struct {
    Stream: UINT,
    SemanticName: [*:0]const u8,
    SemanticIndex: UINT,
    StartComponent: UINT8,
    ComponentCount: UINT8,
    OutputSlot: UINT8,
};

pub const STREAM_OUTPUT_DESC = extern struct {
    pSODeclaration: ?[*]const SO_DECLARATION_ENTRY,
    NumEntries: UINT,
    pBufferStrides: ?[*]const UINT,
    NumStrides: UINT,
    RasterizedStream: UINT,

    pub inline fn initZero() STREAM_OUTPUT_DESC {
        return std.mem.zeroes(@This());
    }
};

pub const BLEND = enum(UINT) {
    ZERO = 1,
    ONE = 2,
    SRC_COLOR = 3,
    INV_SRC_COLOR = 4,
    SRC_ALPHA = 5,
    INV_SRC_ALPHA = 6,
    DEST_ALPHA = 7,
    INV_DEST_ALPHA = 8,
    DEST_COLOR = 9,
    INV_DEST_COLOR = 10,
    SRC_ALPHA_SAT = 11,
    BLEND_FACTOR = 14,
    INV_BLEND_FACTOR = 15,
    SRC1_COLOR = 16,
    INV_SRC1_COLOR = 17,
    SRC1_ALPHA = 18,
    INV_SRC1_ALPHA = 19,
};

pub const BLEND_OP = enum(UINT) {
    ADD = 1,
    SUBTRACT = 2,
    REV_SUBTRACT = 3,
    MIN = 4,
    MAX = 5,
};

pub const LOGIC_OP = enum(UINT) {
    CLEAR = 0,
    SET = 1,
    COPY = 2,
    COPY_INVERTED = 3,
    NOOP = 4,
    INVERT = 5,
    AND = 6,
    NAND = 7,
    OR = 8,
    NOR = 9,
    XOR = 10,
    EQUIV = 11,
    AND_REVERSE = 12,
    AND_INVERTED = 13,
    OR_REVERSE = 14,
    OR_INVERTED = 15,
};

pub const COLOR_WRITE_ENABLE = packed struct(UINT) {
    RED: bool = false,
    GREEN: bool = false,
    BLUE: bool = false,
    ALPHA: bool = false,
    __unused: u28 = 0,

    pub const ALL = COLOR_WRITE_ENABLE{ .RED = true, .GREEN = true, .BLUE = true, .ALPHA = true };
};

pub const RENDER_TARGET_BLEND_DESC = extern struct {
    BlendEnable: BOOL = 0,
    LogicOpEnable: BOOL = 0,
    SrcBlend: BLEND = .ONE,
    DestBlend: BLEND = .ZERO,
    BlendOp: BLEND_OP = .ADD,
    SrcBlendAlpha: BLEND = .ONE,
    DestBlendAlpha: BLEND = .ZERO,
    BlendOpAlpha: BLEND_OP = .ADD,
    LogicOp: LOGIC_OP = .NOOP,
    RenderTargetWriteMask: COLOR_WRITE_ENABLE = COLOR_WRITE_ENABLE.ALL,

    pub fn initDefault() RENDER_TARGET_BLEND_DESC {
        return .{};
    }
};

pub const BLEND_DESC = extern struct {
    AlphaToCoverageEnable: BOOL = 0,
    IndependentBlendEnable: BOOL = 0,
    RenderTarget: [8]RENDER_TARGET_BLEND_DESC = [_]RENDER_TARGET_BLEND_DESC{.{}} ** 8,

    pub fn initDefault() BLEND_DESC {
        return .{};
    }
};

pub const FILL_MODE = enum(UINT) {
    WIREFRAME = 2,
    SOLID = 3,
};

pub const CULL_MODE = enum(UINT) {
    NONE = 1,
    FRONT = 2,
    BACK = 3,
};

pub const CONSERVATIVE_RASTERIZATION_MODE = enum(UINT) {
    OFF = 0,
    ON = 1,
};

pub const RASTERIZER_DESC = extern struct {
    FillMode: FILL_MODE = .SOLID,
    CullMode: CULL_MODE = .BACK,
    FrontCounterClockwise: BOOL = 0,
    DepthBias: INT = 0,
    DepthBiasClamp: FLOAT = 0.0,
    SlopeScaledDepthBias: FLOAT = 0.0,
    DepthClipEnable: BOOL = 1,
    MultisampleEnable: BOOL = 0,
    AntialiasedLineEnable: BOOL = 0,
    ForcedSampleCount: UINT = 0,
    ConservativeRaster: CONSERVATIVE_RASTERIZATION_MODE = .OFF,

    pub fn initDefault() RASTERIZER_DESC {
        return .{};
    }
};

pub const DEPTH_WRITE_MASK = enum(UINT) {
    ZERO = 0,
    ALL = 1,
};

pub const STENCIL_OP = enum(UINT) {
    KEEP = 1,
    ZERO = 2,
    REPLACE = 3,
    INCR_SAT = 4,
    DECR_SAT = 5,
    INVERT = 6,
    INCR = 7,
    DECR = 8,
};

pub const DEPTH_STENCILOP_DESC = extern struct {
    StencilFailOp: STENCIL_OP = .KEEP,
    StencilDepthFailOp: STENCIL_OP = .KEEP,
    StencilPassOp: STENCIL_OP = .KEEP,
    StencilFunc: COMPARISON_FUNC = .ALWAYS,

    pub fn initDefault() DEPTH_STENCILOP_DESC {
        return .{};
    }
};

pub const DEPTH_STENCIL_DESC = extern struct {
    DepthEnable: BOOL = 1,
    DepthWriteMask: DEPTH_WRITE_MASK = .ALL,
    DepthFunc: COMPARISON_FUNC = .LESS,
    StencilEnable: BOOL = 0,
    StencilReadMask: UINT8 = 0xff,
    StencilWriteMask: UINT8 = 0xff,
    FrontFace: DEPTH_STENCILOP_DESC = .{},
    BackFace: DEPTH_STENCILOP_DESC = .{},

    pub fn initDefault() DEPTH_STENCIL_DESC {
        return .{};
    }
};

pub const INPUT_CLASSIFICATION = enum(UINT) {
    PER_VERTEX_DATA = 0,
    PER_INSTANCE_DATA = 1,
};

pub const INPUT_ELEMENT_DESC = extern struct {
    SemanticName: [*:0]const u8,
    SemanticIndex: UINT,
    Format: dxgi.FORMAT,
    InputSlot: UINT,
    AlignedByteOffset: UINT,
    InputSlotClass: INPUT_CLASSIFICATION,
    InstanceDataStepRate: UINT,

    pub inline fn init(
        semanticName: [*:0]const u8,
        semanticIndex: UINT,
        format: dxgi.FORMAT,
        inputSlot: UINT,
        alignedByteOffset: UINT,
        inputSlotClass: INPUT_CLASSIFICATION,
        instanceDataStepRate: UINT,
    ) INPUT_ELEMENT_DESC {
        var v = std.mem.zeroes(@This());
        v = .{
            .SemanticName = semanticName,
            .SemanticIndex = semanticIndex,
            .Format = format,
            .InputSlot = inputSlot,
            .AlignedByteOffset = alignedByteOffset,
            .InputSlotClass = inputSlotClass,
            .InstanceDataStepRate = instanceDataStepRate,
        };
        return v;
    }
};

pub const INPUT_LAYOUT_DESC = extern struct {
    pInputElementDescs: ?[*]const INPUT_ELEMENT_DESC,
    NumElements: UINT,

    pub inline fn initZero() INPUT_LAYOUT_DESC {
        return std.mem.zeroes(@This());
    }

    pub inline fn init(elements: []const INPUT_ELEMENT_DESC) INPUT_LAYOUT_DESC {
        return .{
            .pInputElementDescs = elements.ptr,
            .NumElements = @intCast(elements.len),
        };
    }
};

pub const INDEX_BUFFER_STRIP_CUT_VALUE = enum(UINT) {
    DISABLED = 0,
    OxFFFF = 1,
    OxFFFFFFFF = 2,
};

pub const PRIMITIVE_TOPOLOGY_TYPE = enum(UINT) {
    UNDEFINED = 0,
    POINT = 1,
    LINE = 2,
    TRIANGLE = 3,
    PATCH = 4,
};

pub const CACHED_PIPELINE_STATE = extern struct {
    pCachedBlob: ?*const anyopaque,
    CachedBlobSizeInBytes: UINT64,

    pub inline fn initZero() CACHED_PIPELINE_STATE {
        return std.mem.zeroes(@This());
    }
};

pub const PIPELINE_STATE_FLAGS = packed struct(UINT) {
    TOOL_DEBUG: bool = false,
    __unused1: bool = false,
    DYNAMIC_DEPTH_BIAS: bool = false,
    DYNAMIC_INDEX_BUFFER_STRIP_CUT: bool = false,
    __unused: u28 = 0,
};

pub const GRAPHICS_PIPELINE_STATE_DESC = extern struct {
    pRootSignature: ?*IRootSignature = null,
    VS: SHADER_BYTECODE = .{},
    PS: SHADER_BYTECODE = .{},
    DS: SHADER_BYTECODE = .{},
    HS: SHADER_BYTECODE = .{},
    GS: SHADER_BYTECODE = .{},
    StreamOutput: STREAM_OUTPUT_DESC = STREAM_OUTPUT_DESC.initZero(),
    BlendState: BLEND_DESC = .{},
    SampleMask: UINT = 0xffff_ffff,
    RasterizerState: RASTERIZER_DESC = .{},
    DepthStencilState: DEPTH_STENCIL_DESC = .{},
    InputLayout: INPUT_LAYOUT_DESC = INPUT_LAYOUT_DESC.initZero(),
    IBStripCutValue: INDEX_BUFFER_STRIP_CUT_VALUE = .DISABLED,
    PrimitiveTopologyType: PRIMITIVE_TOPOLOGY_TYPE = .UNDEFINED,
    NumRenderTargets: UINT = 0,
    RTVFormats: [8]dxgi.FORMAT = [_]dxgi.FORMAT{.UNKNOWN} ** 8,
    DSVFormat: dxgi.FORMAT = .UNKNOWN,
    SampleDesc: dxgi.SAMPLE_DESC = .{ .Count = 1, .Quality = 0 },
    NodeMask: UINT = 0,
    CachedPSO: CACHED_PIPELINE_STATE = CACHED_PIPELINE_STATE.initZero(),
    Flags: PIPELINE_STATE_FLAGS = .{},

    pub fn initDefault() GRAPHICS_PIPELINE_STATE_DESC {
        return .{};
    }
};

pub const SHADER_MACRO = extern struct {
    Name: LPCSTR,
    Definition: LPCSTR,
};

pub const BUFFER_RTV = extern struct {
    FirstElement: UINT64,
    NumElements: UINT,
};

pub const TEX1D_RTV = extern struct {
    MipSlice: UINT,
};

pub const TEX1D_ARRAY_RTV = extern struct {
    MipSlice: UINT,
    FirstArraySlice: UINT,
    ArraySize: UINT,
};

pub const TEX2D_RTV = extern struct {
    MipSlice: UINT,
    PlaneSlice: UINT,
};

pub const TEX2DMS_RTV = extern struct {
    UnusedField_NothingToDefine: UINT,
};

pub const TEX2D_ARRAY_RTV = extern struct {
    MipSlice: UINT,
    FirstArraySlice: UINT,
    ArraySize: UINT,
    PlaneSlice: UINT,
};

pub const TEX2DMS_ARRAY_RTV = extern struct {
    FirstArraySlice: UINT,
    ArraySize: UINT,
};

pub const TEX3D_RTV = extern struct {
    MipSlice: UINT,
    FirstWSlice: UINT,
    WSize: UINT,
};

pub const RTV_DIMENSION = enum(UINT) {
    UNKNOWN = 0,
    BUFFER = 1,
    TEXTURE1D = 2,
    TEXTURE1DARRAY = 3,
    TEXTURE2D = 4,
    TEXTURE2DARRAY = 5,
    TEXTURE2DMS = 6,
    TEXTURE2DMSARRAY = 7,
    TEXTURE3D = 8,
};

pub const RENDER_TARGET_VIEW_DESC = extern struct {
    Format: dxgi.FORMAT,
    ViewDimension: RTV_DIMENSION,
    u: extern union {
        Buffer: BUFFER_RTV,
        Texture1D: TEX1D_RTV,
        Texture1DArray: TEX1D_ARRAY_RTV,
        Texture2D: TEX2D_RTV,
        Texture2DArray: TEX2D_ARRAY_RTV,
        Texture2DMS: TEX2DMS_RTV,
        Texture2DMSArray: TEX2DMS_ARRAY_RTV,
        Texture3D: TEX3D_RTV,
    },
};

pub const TEX1D_DSV = extern struct {
    MipSlice: UINT,
};

pub const TEX1D_ARRAY_DSV = extern struct {
    MipSlice: UINT,
    FirstArraySlice: UINT,
    ArraySize: UINT,
};

pub const TEX2D_DSV = extern struct {
    MipSlice: UINT,
};

pub const TEX2D_ARRAY_DSV = extern struct {
    MipSlice: UINT,
    FirstArraySlice: UINT,
    ArraySize: UINT,
};

pub const TEX2DMS_DSV = extern struct {
    UnusedField_NothingToDefine: UINT,
};

pub const TEX2DMS_ARRAY_DSV = extern struct {
    FirstArraySlice: UINT,
    ArraySize: UINT,
};

pub const DSV_FLAGS = packed struct(UINT) {
    READ_ONLY_DEPTH: bool = false,
    READ_ONLY_STENCIL: bool = false,
    __unused: u30 = 0,
};

pub const DSV_DIMENSION = enum(UINT) {
    UNKNOWN = 0,
    TEXTURE1D = 1,
    TEXTURE1DARRAY = 2,
    TEXTURE2D = 3,
    TEXTURE2DARRAY = 4,
    TEXTURE2DMS = 5,
    TEXTURE2DMSARRAY = 6,
};

pub const DEPTH_STENCIL_VIEW_DESC = extern struct {
    Format: dxgi.FORMAT,
    ViewDimension: DSV_DIMENSION,
    Flags: DSV_FLAGS,
    u: extern union {
        Texture1D: TEX1D_DSV,
        Texture1DArray: TEX1D_ARRAY_DSV,
        Texture2D: TEX2D_DSV,
        Texture2DArray: TEX2D_ARRAY_DSV,
        Texture2DMS: TEX2DMS_DSV,
        Texture2DMSArray: TEX2DMS_ARRAY_DSV,
    },
};

pub const DEPTH_STENCIL_VALUE = extern struct {
    Depth: FLOAT,
    Stencil: UINT8,
};

pub const CLEAR_VALUE = extern struct {
    Format: dxgi.FORMAT,
    u: extern union {
        Color: [4]FLOAT,
        DepthStencil: DEPTH_STENCIL_VALUE,
    },
};

pub const RESOURCE_BINDING_TIER = enum(UINT) {
    TIER_1 = 1,
    TIER_2 = 2,
    TIER_3 = 3,
};

pub const RESOURCE_HEAP_TIER = enum(UINT) {
    TIER_1 = 1,
    TIER_2 = 2,
};

pub const SHADER_MIN_PRECISION_SUPPORT = packed struct(UINT) {
    @"10_BIT": bool = false,
    @"16_BIT": bool = false,
    __unused: u30 = 0,
};

pub const TILED_RESOURCES_TIER = enum(UINT) {
    NOT_SUPPORTED = 0,
    TIER_1 = 1,
    TIER_2 = 2,
    TIER_3 = 3,
    TIER_4 = 4,
};

pub const CONSERVATIVE_RASTERIZATION_TIER = enum(UINT) {
    NOT_SUPPORTED = 0,
    TIER_1 = 1,
    TIER_2 = 2,
    TIER_3 = 3,
};

pub const CROSS_NODE_SHARING_TIER = enum(UINT) {
    NOT_SUPPORTED = 0,
    TIER_1_EMULATED = 1,
    TIER_1 = 2,
    TIER_2 = 3,
    TIER_3 = 4,
};

pub const FEATURE_DATA_D3D12_OPTIONS = extern struct {
    DoublePrecisionFloatShaderOps: BOOL,
    OutputMergerLogicOp: BOOL,
    MinPrecisionSupport: SHADER_MIN_PRECISION_SUPPORT,
    TiledResourcesTier: TILED_RESOURCES_TIER,
    ResourceBindingTier: RESOURCE_BINDING_TIER,
    PSSpecifiedStencilRefSupported: BOOL,
    TypedUAVLoadAdditionalFormats: BOOL,
    ROVsSupported: BOOL,
    ConservativeRasterizationTier: CONSERVATIVE_RASTERIZATION_TIER,
    MaxGPUVirtualAddressBitsPerResource: UINT,
    StandardSwizzle64KBSupported: BOOL,
    CrossNodeSharingTier: CROSS_NODE_SHARING_TIER,
    CrossAdapterRowMajorTextureSupported: BOOL,
    VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation: BOOL,
    ResourceHeapTier: RESOURCE_HEAP_TIER,
};

pub const HEAP_DESC = extern struct {
    SizeInBytes: UINT64,
    Properties: HEAP_PROPERTIES,
    Alignment: UINT64,
    Flags: HEAP_FLAGS,
};

pub const RESOURCE_ALLOCATION_INFO = extern struct {
    SizeInBytes: UINT64,
    Alignment: UINT64,
};

// functions
// ---------

pub extern "d3d12" fn D3D12GetDebugInterface(riid: *const GUID, ppvDebug: *?*anyopaque) callconv(.winapi) HRESULT;
pub extern "d3d12" fn D3D12CreateDevice(pAdapter: ?*IUnknown, MinimumFeatureLevel: FEATURE_LEVEL, riid: *const GUID, ppDevice: ?*?*anyopaque) callconv(.winapi) HRESULT;
pub extern "d3d12" fn D3D12SerializeRootSignature(pRootSignature: *const ROOT_SIGNATURE_DESC, Version: ROOT_SIGNATURE_VERSION, ppBlob: *?*IBlob, ppErrorBlob: *?*IBlob) callconv(.winapi) HRESULT;
pub extern "D3DCompiler_47" fn D3DCompile(
    pSrcData: *const anyopaque,
    SrcDataSize: SIZE_T,
    pSourceName: ?LPCSTR,
    pDefines: ?*const SHADER_MACRO,
    pInclude: ?*const anyopaque, // FIXME IInclude
    pEntrypoint: LPCSTR,
    pTarget: LPCSTR,
    Flags1: UINT,
    Flags2: UINT,
    ppCode: **IBlob,
    ppErrorMsgs: ?**IBlob,
) callconv(.winapi) HRESULT;

// THIS FILE IS AUTOGENERATED BEYOND THIS POINT! DO NOT EDIT!
// ----------------------------------------------------------

pub const IBlob = extern struct {
    pub const IID = GUID.parse("{8BA5FB08-5195-40E2-AC58-0D989C3A0102}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IUnknown.VTable,
        get_buffer_pointer: *const fn (*IBlob) callconv(.winapi) *anyopaque,
        get_buffer_size: *const fn (*IBlob) callconv(.winapi) SIZE_T,
    };

    pub fn getBufferPointer(self: *IBlob) *anyopaque {
        return (self.vtable.get_buffer_pointer)(self);
    }
    pub fn getBufferSize(self: *IBlob) SIZE_T {
        return (self.vtable.get_buffer_size)(self);
    }
    // IUnknown methods
    pub fn queryInterface(self: *IBlob, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IBlob) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IBlob) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IDeviceChild = extern struct {
    pub const IID = GUID.parse("{905DB94B-A00C-4140-9DF5-2B64CA9EA357}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IObject.VTable,
        get_device: *const fn (*IDeviceChild, riid: *const GUID, device: *?*anyopaque) callconv(.winapi) HRESULT,
    };

    pub fn getDevice(self: *IDeviceChild, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (self.vtable.get_device)(self, riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IDeviceChild) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IDeviceChild) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IDeviceChild) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IDeviceChild) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IDeviceChild, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IDeviceChild) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IDeviceChild) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IPageable = extern struct {
    pub const IID = GUID.parse("{63EE58FB-1268-4835-86DA-F008CE62F0D6}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IDeviceChild.VTable,
    };
    // IDeviceChild methods
    pub fn getDevice(self: *IPageable, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IPageable) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IPageable) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IPageable) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IPageable) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IPageable, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IPageable) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IPageable) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IDebug = extern struct {
    pub const IID = GUID.parse("{344488B7-6846-474B-B989-F027448245E0}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IUnknown.VTable,
        enable_debug_layer: *const fn (*IDebug) callconv(.winapi) void,
    };

    pub fn enableDebugLayer(self: *IDebug) void {
        return (self.vtable.enable_debug_layer)(self);
    }
    // IUnknown methods
    pub fn queryInterface(self: *IDebug, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IDebug) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IDebug) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IDebug1 = extern struct {
    pub const IID = GUID.parse("{AFFAA4CA-63FE-4D8E-B8AD-159000AF4304}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IDebug.VTable,
        set_enable_g_p_u_based_validation: *const fn (*IDebug1, enable: BOOL) callconv(.winapi) void,
        set_enable_synchronized_command_queue_validation: *const fn (*IDebug1, enable: BOOL) callconv(.winapi) void,
    };

    pub fn setEnableGPUBasedValidation(self: *IDebug1, enable: BOOL) void {
        return (self.vtable.set_enable_g_p_u_based_validation)(self, enable);
    }
    pub fn setEnableSynchronizedCommandQueueValidation(self: *IDebug1, enable: BOOL) void {
        return (self.vtable.set_enable_synchronized_command_queue_validation)(self, enable);
    }
    // IDebug methods
    pub fn enableDebugLayer(self: *IDebug1) void {
        return (@as(*const IDebug.VTable, @ptrCast(self.vtable)).enable_debug_layer)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IDebug1, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IDebug1) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IDebug1) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IInfoQueue = extern struct {
    pub const IID = GUID.parse("{0742A90B-C387-483F-B946-30A7E4E61458}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IUnknown.VTable,
        set_message_count_limit: *const fn (*IInfoQueue, message_count_limit: u64) callconv(.winapi) HRESULT,
        clear_stored_messages: *const fn (*IInfoQueue) callconv(.winapi) void,
        get_message_a: *const fn (*IInfoQueue, message_index: u64, message: *MESSAGE, message_byte_length: *u32) callconv(.winapi) HRESULT,
        get_num_messages_allowed_by_storage_filter: *const fn (*IInfoQueue) callconv(.winapi) u64,
        get_num_messages_denied_by_storage_filter: *const fn (*IInfoQueue) callconv(.winapi) u64,
        get_num_stored_messages: *const fn (*IInfoQueue) callconv(.winapi) u64,
        get_num_stored_messages_allowed_by_retrieval_filter: *const fn (*IInfoQueue) callconv(.winapi) u64,
        get_num_messages_discarded_by_message_count_limit: *const fn (*IInfoQueue) callconv(.winapi) u64,
        get_message_count_limit: *const fn (*IInfoQueue) callconv(.winapi) u64,
        add_storage_filter_entries: *const fn (*IInfoQueue, filter: *INFO_QUEUE_FILTER) callconv(.winapi) HRESULT,
        get_storage_filter: *const fn (*IInfoQueue, filter: *INFO_QUEUE_FILTER, pFilterByteLength: *u32) callconv(.winapi) HRESULT,
        clear_storage_filter: *const fn (*IInfoQueue) callconv(.winapi) void,
        push_empty_storage_filter: *const fn (*IInfoQueue) callconv(.winapi) HRESULT,
        push_copy_of_storage_filter: *const fn (*IInfoQueue) callconv(.winapi) HRESULT,
        push_storage_filter: *const fn (*IInfoQueue, filter: *INFO_QUEUE_FILTER) callconv(.winapi) HRESULT,
        pop_storage_filter: *const fn (*IInfoQueue) callconv(.winapi) void,
        get_storage_filter_stack_size: *const fn (*IInfoQueue) callconv(.winapi) u32,
        add_retrieval_filter_entries: *const fn (*IInfoQueue, filter: *INFO_QUEUE_FILTER) callconv(.winapi) HRESULT,
        get_retrieval_filter: *const fn (*IInfoQueue, filter: *INFO_QUEUE_FILTER, filter_byte_length: *u32) callconv(.winapi) HRESULT,
        clear_retrieval_filter: *const fn (*IInfoQueue) callconv(.winapi) void,
        push_empty_retrieval_filter: *const fn (*IInfoQueue) callconv(.winapi) HRESULT,
        push_copy_of_retrieval_filter: *const fn (*IInfoQueue) callconv(.winapi) HRESULT,
        push_retrieval_filter: *const fn (*IInfoQueue, filter: *INFO_QUEUE_FILTER) callconv(.winapi) HRESULT,
        pop_retrieval_filter: *const fn (*IInfoQueue) callconv(.winapi) void,
        get_retrieval_filter_stack_size: *const fn (*IInfoQueue) callconv(.winapi) u32,
        add_message: *const fn (*IInfoQueue, category: MESSAGE_CATEGORY, severity: MESSAGE_SEVERITY, id: MESSAGE_ID, description: [*c]const u8) callconv(.winapi) HRESULT,
        add_application_message: *const fn (*IInfoQueue, severity: MESSAGE_SEVERITY, description: [*c]const u8) callconv(.winapi) HRESULT,
        set_break_on_category: *const fn (*IInfoQueue, category: MESSAGE_CATEGORY, enable: BOOL) callconv(.winapi) HRESULT,
        set_break_on_severity: *const fn (*IInfoQueue, severity: MESSAGE_SEVERITY, enable: BOOL) callconv(.winapi) HRESULT,
        set_break_on_i_d: *const fn (*IInfoQueue, id: MESSAGE_ID, enable: BOOL) callconv(.winapi) HRESULT,
        get_break_on_category: *const fn (*IInfoQueue, category: MESSAGE_CATEGORY) callconv(.winapi) BOOL,
        get_break_on_severity: *const fn (*IInfoQueue, severity: MESSAGE_SEVERITY) callconv(.winapi) BOOL,
        get_break_on_i_d: *const fn (*IInfoQueue, id: MESSAGE_ID) callconv(.winapi) BOOL,
        set_mute_debug_output: *const fn (*IInfoQueue, b_mute: BOOL) callconv(.winapi) void,
        get_mute_debug_output: *const fn (*IInfoQueue) callconv(.winapi) BOOL,
    };

    pub fn setMessageCountLimit(self: *IInfoQueue, message_count_limit: u64) HRESULT {
        return (self.vtable.set_message_count_limit)(self, message_count_limit);
    }
    pub fn clearStoredMessages(self: *IInfoQueue) void {
        return (self.vtable.clear_stored_messages)(self);
    }
    pub fn getMessageA(self: *IInfoQueue, message_index: u64, message: *MESSAGE, message_byte_length: *u32) HRESULT {
        return (self.vtable.get_message_a)(self, message_index, message, message_byte_length);
    }
    pub fn getNumMessagesAllowedByStorageFilter(self: *IInfoQueue) u64 {
        return (self.vtable.get_num_messages_allowed_by_storage_filter)(self);
    }
    pub fn getNumMessagesDeniedByStorageFilter(self: *IInfoQueue) u64 {
        return (self.vtable.get_num_messages_denied_by_storage_filter)(self);
    }
    pub fn getNumStoredMessages(self: *IInfoQueue) u64 {
        return (self.vtable.get_num_stored_messages)(self);
    }
    pub fn getNumStoredMessagesAllowedByRetrievalFilter(self: *IInfoQueue) u64 {
        return (self.vtable.get_num_stored_messages_allowed_by_retrieval_filter)(self);
    }
    pub fn getNumMessagesDiscardedByMessageCountLimit(self: *IInfoQueue) u64 {
        return (self.vtable.get_num_messages_discarded_by_message_count_limit)(self);
    }
    pub fn getMessageCountLimit(self: *IInfoQueue) u64 {
        return (self.vtable.get_message_count_limit)(self);
    }
    pub fn addStorageFilterEntries(self: *IInfoQueue, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (self.vtable.add_storage_filter_entries)(self, filter);
    }
    pub fn getStorageFilter(self: *IInfoQueue, filter: *INFO_QUEUE_FILTER, pFilterByteLength: *u32) HRESULT {
        return (self.vtable.get_storage_filter)(self, filter, pFilterByteLength);
    }
    pub fn clearStorageFilter(self: *IInfoQueue) void {
        return (self.vtable.clear_storage_filter)(self);
    }
    pub fn pushEmptyStorageFilter(self: *IInfoQueue) HRESULT {
        return (self.vtable.push_empty_storage_filter)(self);
    }
    pub fn pushCopyOfStorageFilter(self: *IInfoQueue) HRESULT {
        return (self.vtable.push_copy_of_storage_filter)(self);
    }
    pub fn pushStorageFilter(self: *IInfoQueue, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (self.vtable.push_storage_filter)(self, filter);
    }
    pub fn popStorageFilter(self: *IInfoQueue) void {
        return (self.vtable.pop_storage_filter)(self);
    }
    pub fn getStorageFilterStackSize(self: *IInfoQueue) u32 {
        return (self.vtable.get_storage_filter_stack_size)(self);
    }
    pub fn addRetrievalFilterEntries(self: *IInfoQueue, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (self.vtable.add_retrieval_filter_entries)(self, filter);
    }
    pub fn getRetrievalFilter(self: *IInfoQueue, filter: *INFO_QUEUE_FILTER, filter_byte_length: *u32) HRESULT {
        return (self.vtable.get_retrieval_filter)(self, filter, filter_byte_length);
    }
    pub fn clearRetrievalFilter(self: *IInfoQueue) void {
        return (self.vtable.clear_retrieval_filter)(self);
    }
    pub fn pushEmptyRetrievalFilter(self: *IInfoQueue) HRESULT {
        return (self.vtable.push_empty_retrieval_filter)(self);
    }
    pub fn pushCopyOfRetrievalFilter(self: *IInfoQueue) HRESULT {
        return (self.vtable.push_copy_of_retrieval_filter)(self);
    }
    pub fn pushRetrievalFilter(self: *IInfoQueue, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (self.vtable.push_retrieval_filter)(self, filter);
    }
    pub fn popRetrievalFilter(self: *IInfoQueue) void {
        return (self.vtable.pop_retrieval_filter)(self);
    }
    pub fn getRetrievalFilterStackSize(self: *IInfoQueue) u32 {
        return (self.vtable.get_retrieval_filter_stack_size)(self);
    }
    pub fn addMessage(self: *IInfoQueue, category: MESSAGE_CATEGORY, severity: MESSAGE_SEVERITY, id: MESSAGE_ID, description: [*c]const u8) HRESULT {
        return (self.vtable.add_message)(self, category, severity, id, description);
    }
    pub fn addApplicationMessage(self: *IInfoQueue, severity: MESSAGE_SEVERITY, description: [*c]const u8) HRESULT {
        return (self.vtable.add_application_message)(self, severity, description);
    }
    pub fn setBreakOnCategory(self: *IInfoQueue, category: MESSAGE_CATEGORY, enable: BOOL) HRESULT {
        return (self.vtable.set_break_on_category)(self, category, enable);
    }
    pub fn setBreakOnSeverity(self: *IInfoQueue, severity: MESSAGE_SEVERITY, enable: BOOL) HRESULT {
        return (self.vtable.set_break_on_severity)(self, severity, enable);
    }
    pub fn setBreakOnID(self: *IInfoQueue, id: MESSAGE_ID, enable: BOOL) HRESULT {
        return (self.vtable.set_break_on_i_d)(self, id, enable);
    }
    pub fn getBreakOnCategory(self: *IInfoQueue, category: MESSAGE_CATEGORY) BOOL {
        return (self.vtable.get_break_on_category)(self, category);
    }
    pub fn getBreakOnSeverity(self: *IInfoQueue, severity: MESSAGE_SEVERITY) BOOL {
        return (self.vtable.get_break_on_severity)(self, severity);
    }
    pub fn getBreakOnID(self: *IInfoQueue, id: MESSAGE_ID) BOOL {
        return (self.vtable.get_break_on_i_d)(self, id);
    }
    pub fn setMuteDebugOutput(self: *IInfoQueue, b_mute: BOOL) void {
        return (self.vtable.set_mute_debug_output)(self, b_mute);
    }
    pub fn getMuteDebugOutput(self: *IInfoQueue) BOOL {
        return (self.vtable.get_mute_debug_output)(self);
    }
    // IUnknown methods
    pub fn queryInterface(self: *IInfoQueue, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IInfoQueue) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IInfoQueue) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IInfoQueue1 = extern struct {
    pub const IID = GUID.parse("{2852DD88-B484-4C0C-B6B1-67168500E600}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IInfoQueue.VTable,
        register_message_callback: *const fn (*IInfoQueue1, callback_func: PFN_MESSAGE_CALLBACK, callback_filter_flags: MESSAGE_CALLBACK_FLAGS, context: ?*anyopaque, callback_cookie: *u32) callconv(.winapi) HRESULT,
        unregister_message_callback: *const fn (*IInfoQueue1, callback_cookie: u32) callconv(.winapi) HRESULT,
    };

    pub fn registerMessageCallback(self: *IInfoQueue1, callback_func: PFN_MESSAGE_CALLBACK, callback_filter_flags: MESSAGE_CALLBACK_FLAGS, context: ?*anyopaque, callback_cookie: *u32) HRESULT {
        return (self.vtable.register_message_callback)(self, callback_func, callback_filter_flags, context, callback_cookie);
    }
    pub fn unregisterMessageCallback(self: *IInfoQueue1, callback_cookie: u32) HRESULT {
        return (self.vtable.unregister_message_callback)(self, callback_cookie);
    }
    // IInfoQueue methods
    pub fn setMessageCountLimit(self: *IInfoQueue1, message_count_limit: u64) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).set_message_count_limit)(@ptrCast(self), message_count_limit);
    }
    pub fn clearStoredMessages(self: *IInfoQueue1) void {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).clear_stored_messages)(@ptrCast(self));
    }
    pub fn getMessageA(self: *IInfoQueue1, message_index: u64, message: *MESSAGE, message_byte_length: *u32) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_message_a)(@ptrCast(self), message_index, message, message_byte_length);
    }
    pub fn getNumMessagesAllowedByStorageFilter(self: *IInfoQueue1) u64 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_num_messages_allowed_by_storage_filter)(@ptrCast(self));
    }
    pub fn getNumMessagesDeniedByStorageFilter(self: *IInfoQueue1) u64 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_num_messages_denied_by_storage_filter)(@ptrCast(self));
    }
    pub fn getNumStoredMessages(self: *IInfoQueue1) u64 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_num_stored_messages)(@ptrCast(self));
    }
    pub fn getNumStoredMessagesAllowedByRetrievalFilter(self: *IInfoQueue1) u64 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_num_stored_messages_allowed_by_retrieval_filter)(@ptrCast(self));
    }
    pub fn getNumMessagesDiscardedByMessageCountLimit(self: *IInfoQueue1) u64 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_num_messages_discarded_by_message_count_limit)(@ptrCast(self));
    }
    pub fn getMessageCountLimit(self: *IInfoQueue1) u64 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_message_count_limit)(@ptrCast(self));
    }
    pub fn addStorageFilterEntries(self: *IInfoQueue1, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).add_storage_filter_entries)(@ptrCast(self), filter);
    }
    pub fn getStorageFilter(self: *IInfoQueue1, filter: *INFO_QUEUE_FILTER, pFilterByteLength: *u32) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_storage_filter)(@ptrCast(self), filter, pFilterByteLength);
    }
    pub fn clearStorageFilter(self: *IInfoQueue1) void {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).clear_storage_filter)(@ptrCast(self));
    }
    pub fn pushEmptyStorageFilter(self: *IInfoQueue1) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).push_empty_storage_filter)(@ptrCast(self));
    }
    pub fn pushCopyOfStorageFilter(self: *IInfoQueue1) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).push_copy_of_storage_filter)(@ptrCast(self));
    }
    pub fn pushStorageFilter(self: *IInfoQueue1, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).push_storage_filter)(@ptrCast(self), filter);
    }
    pub fn popStorageFilter(self: *IInfoQueue1) void {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).pop_storage_filter)(@ptrCast(self));
    }
    pub fn getStorageFilterStackSize(self: *IInfoQueue1) u32 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_storage_filter_stack_size)(@ptrCast(self));
    }
    pub fn addRetrievalFilterEntries(self: *IInfoQueue1, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).add_retrieval_filter_entries)(@ptrCast(self), filter);
    }
    pub fn getRetrievalFilter(self: *IInfoQueue1, filter: *INFO_QUEUE_FILTER, filter_byte_length: *u32) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_retrieval_filter)(@ptrCast(self), filter, filter_byte_length);
    }
    pub fn clearRetrievalFilter(self: *IInfoQueue1) void {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).clear_retrieval_filter)(@ptrCast(self));
    }
    pub fn pushEmptyRetrievalFilter(self: *IInfoQueue1) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).push_empty_retrieval_filter)(@ptrCast(self));
    }
    pub fn pushCopyOfRetrievalFilter(self: *IInfoQueue1) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).push_copy_of_retrieval_filter)(@ptrCast(self));
    }
    pub fn pushRetrievalFilter(self: *IInfoQueue1, filter: *INFO_QUEUE_FILTER) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).push_retrieval_filter)(@ptrCast(self), filter);
    }
    pub fn popRetrievalFilter(self: *IInfoQueue1) void {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).pop_retrieval_filter)(@ptrCast(self));
    }
    pub fn getRetrievalFilterStackSize(self: *IInfoQueue1) u32 {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_retrieval_filter_stack_size)(@ptrCast(self));
    }
    pub fn addMessage(self: *IInfoQueue1, category: MESSAGE_CATEGORY, severity: MESSAGE_SEVERITY, id: MESSAGE_ID, description: [*c]const u8) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).add_message)(@ptrCast(self), category, severity, id, description);
    }
    pub fn addApplicationMessage(self: *IInfoQueue1, severity: MESSAGE_SEVERITY, description: [*c]const u8) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).add_application_message)(@ptrCast(self), severity, description);
    }
    pub fn setBreakOnCategory(self: *IInfoQueue1, category: MESSAGE_CATEGORY, enable: BOOL) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).set_break_on_category)(@ptrCast(self), category, enable);
    }
    pub fn setBreakOnSeverity(self: *IInfoQueue1, severity: MESSAGE_SEVERITY, enable: BOOL) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).set_break_on_severity)(@ptrCast(self), severity, enable);
    }
    pub fn setBreakOnID(self: *IInfoQueue1, id: MESSAGE_ID, enable: BOOL) HRESULT {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).set_break_on_i_d)(@ptrCast(self), id, enable);
    }
    pub fn getBreakOnCategory(self: *IInfoQueue1, category: MESSAGE_CATEGORY) BOOL {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_break_on_category)(@ptrCast(self), category);
    }
    pub fn getBreakOnSeverity(self: *IInfoQueue1, severity: MESSAGE_SEVERITY) BOOL {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_break_on_severity)(@ptrCast(self), severity);
    }
    pub fn getBreakOnID(self: *IInfoQueue1, id: MESSAGE_ID) BOOL {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_break_on_i_d)(@ptrCast(self), id);
    }
    pub fn setMuteDebugOutput(self: *IInfoQueue1, b_mute: BOOL) void {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).set_mute_debug_output)(@ptrCast(self), b_mute);
    }
    pub fn getMuteDebugOutput(self: *IInfoQueue1) BOOL {
        return (@as(*const IInfoQueue.VTable, @ptrCast(self.vtable)).get_mute_debug_output)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IInfoQueue1, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IInfoQueue1) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IInfoQueue1) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IDevice = extern struct {
    pub const IID = GUID.parse("{189819F1-1DB6-4B57-BE54-1821339B85F7}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IObject.VTable,
        get_node_count: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_command_queue: *const fn (*IDevice, desc: *const COMMAND_QUEUE_DESC, riid: *const GUID, command_queue: *?*anyopaque) callconv(.winapi) HRESULT,
        create_command_allocator: *const fn (*IDevice, cmdlist_type: COMMAND_LIST_TYPE, guid: *const GUID, obj: *?*anyopaque) callconv(.winapi) HRESULT,
        create_graphics_pipeline_state: *const fn (*IDevice, desc: *const GRAPHICS_PIPELINE_STATE_DESC, riid: *const GUID, pso: *?*anyopaque) callconv(.winapi) HRESULT,
        create_compute_pipeline_state: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_command_list: *const fn (*IDevice, node_mask: UINT, cmdlist_type: COMMAND_LIST_TYPE, cmdalloc: *ICommandAllocator, initial_state: ?*IPipelineState, guid: *const GUID, cmdlist: *?*anyopaque) callconv(.winapi) HRESULT,
        check_feature_support: *const fn (*IDevice, feature: FEATURE, data: *anyopaque, size: UINT) callconv(.winapi) HRESULT,
        create_descriptor_heap: *const fn (*IDevice, desc: *const DESCRIPTOR_HEAP_DESC, riid: *const GUID, heap: *?*anyopaque) callconv(.winapi) HRESULT,
        get_descriptor_handle_increment_size: *const fn (*IDevice, heap_type: DESCRIPTOR_HEAP_TYPE) callconv(.winapi) UINT,
        create_root_signature: *const fn (*IDevice, node_mask: u32, blob: *anyopaque, blob_length: SIZE_T, riid: *const GUID, root_signature: *?*anyopaque) callconv(.winapi) HRESULT,
        create_constant_buffer_view: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_shader_resource_view: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_unordered_access_view: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_render_target_view: *const fn (*IDevice, resource: ?*IResource, desc: ?*const RENDER_TARGET_VIEW_DESC, dst_descriptor: CPU_DESCRIPTOR_HANDLE) callconv(.winapi) void,
        create_depth_stencil_view: *const fn (*IDevice, resource: ?*IResource, desc: ?*const DEPTH_STENCIL_VIEW_DESC, dst_descriptor: CPU_DESCRIPTOR_HANDLE) callconv(.winapi) void,
        create_sampler: *const fn (*IDevice) callconv(.winapi) noreturn,
        copy_descriptors: *const fn (*IDevice) callconv(.winapi) noreturn,
        copy_descriptors_simple: *const fn (*IDevice) callconv(.winapi) noreturn,
        get_resource_allocation_info: *const fn (*IDevice, info: *RESOURCE_ALLOCATION_INFO, visible_mask: UINT, num_descs: UINT, descs: [*]const RESOURCE_DESC) callconv(.winapi) void,
        get_custom_heap_properties: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_committed_resource: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_heap: *const fn (*IDevice, desc: *const HEAP_DESC, guid: *const GUID, heap: *?*anyopaque) callconv(.winapi) HRESULT,
        create_placed_resource: *const fn (*IDevice, heap: *IHeap, heap_offset: UINT64, desc: *const RESOURCE_DESC, state: RESOURCE_STATES, clear_value: ?*const CLEAR_VALUE, guid: *const GUID, resource: *?*anyopaque) callconv(.winapi) HRESULT,
        create_reserved_resource: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_shared_handle: *const fn (*IDevice) callconv(.winapi) noreturn,
        open_shared_handle: *const fn (*IDevice) callconv(.winapi) noreturn,
        open_shared_handle_by_name: *const fn (*IDevice) callconv(.winapi) noreturn,
        make_resident: *const fn (*IDevice) callconv(.winapi) noreturn,
        evict: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_fence: *const fn (*IDevice, initial_value: u64, flags: FENCE_FLAGS, riid: *const GUID, fence: *?*anyopaque) callconv(.winapi) HRESULT,
        get_device_removed_reason: *const fn (*IDevice) callconv(.winapi) noreturn,
        get_copyable_footprints: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_query_heap: *const fn (*IDevice) callconv(.winapi) noreturn,
        set_stable_power_state: *const fn (*IDevice) callconv(.winapi) noreturn,
        create_command_signature: *const fn (*IDevice, desc: *const COMMAND_SIGNATURE_DESC, root_signature: ?*IRootSignature, riid: *const GUID, signature: ?*?*anyopaque) callconv(.winapi) HRESULT,
        get_resource_tiling: *const fn (*IDevice) callconv(.winapi) noreturn,
        get_adapter_luid: *const fn (*IDevice) callconv(.winapi) noreturn,
    };

    pub fn getNodeCount(self: *IDevice) noreturn {
        return (self.vtable.get_node_count)(self);
    }
    pub fn createCommandQueue(self: *IDevice, desc: *const COMMAND_QUEUE_DESC, riid: *const GUID, command_queue: *?*anyopaque) HRESULT {
        return (self.vtable.create_command_queue)(self, desc, riid, command_queue);
    }
    pub fn createCommandAllocator(self: *IDevice, cmdlist_type: COMMAND_LIST_TYPE, guid: *const GUID, obj: *?*anyopaque) HRESULT {
        return (self.vtable.create_command_allocator)(self, cmdlist_type, guid, obj);
    }
    pub fn createGraphicsPipelineState(self: *IDevice, desc: *const GRAPHICS_PIPELINE_STATE_DESC, riid: *const GUID, pso: *?*anyopaque) HRESULT {
        return (self.vtable.create_graphics_pipeline_state)(self, desc, riid, pso);
    }
    pub fn createComputePipelineState(self: *IDevice) noreturn {
        return (self.vtable.create_compute_pipeline_state)(self);
    }
    pub fn createCommandList(self: *IDevice, node_mask: UINT, cmdlist_type: COMMAND_LIST_TYPE, cmdalloc: *ICommandAllocator, initial_state: ?*IPipelineState, guid: *const GUID, cmdlist: *?*anyopaque) HRESULT {
        return (self.vtable.create_command_list)(self, node_mask, cmdlist_type, cmdalloc, initial_state, guid, cmdlist);
    }
    pub fn checkFeatureSupport(self: *IDevice, feature: FEATURE, data: *anyopaque, size: UINT) HRESULT {
        return (self.vtable.check_feature_support)(self, feature, data, size);
    }
    pub fn createDescriptorHeap(self: *IDevice, desc: *const DESCRIPTOR_HEAP_DESC, riid: *const GUID, heap: *?*anyopaque) HRESULT {
        return (self.vtable.create_descriptor_heap)(self, desc, riid, heap);
    }
    pub fn getDescriptorHandleIncrementSize(self: *IDevice, heap_type: DESCRIPTOR_HEAP_TYPE) UINT {
        return (self.vtable.get_descriptor_handle_increment_size)(self, heap_type);
    }
    pub fn createRootSignature(self: *IDevice, node_mask: u32, blob: *anyopaque, blob_length: SIZE_T, riid: *const GUID, root_signature: *?*anyopaque) HRESULT {
        return (self.vtable.create_root_signature)(self, node_mask, blob, blob_length, riid, root_signature);
    }
    pub fn createConstantBufferView(self: *IDevice) noreturn {
        return (self.vtable.create_constant_buffer_view)(self);
    }
    pub fn createShaderResourceView(self: *IDevice) noreturn {
        return (self.vtable.create_shader_resource_view)(self);
    }
    pub fn createUnorderedAccessView(self: *IDevice) noreturn {
        return (self.vtable.create_unordered_access_view)(self);
    }
    pub fn createRenderTargetView(self: *IDevice, resource: ?*IResource, desc: ?*const RENDER_TARGET_VIEW_DESC, dst_descriptor: CPU_DESCRIPTOR_HANDLE) void {
        return (self.vtable.create_render_target_view)(self, resource, desc, dst_descriptor);
    }
    pub fn createDepthStencilView(self: *IDevice, resource: ?*IResource, desc: ?*const DEPTH_STENCIL_VIEW_DESC, dst_descriptor: CPU_DESCRIPTOR_HANDLE) void {
        return (self.vtable.create_depth_stencil_view)(self, resource, desc, dst_descriptor);
    }
    pub fn createSampler(self: *IDevice) noreturn {
        return (self.vtable.create_sampler)(self);
    }
    pub fn copyDescriptors(self: *IDevice) noreturn {
        return (self.vtable.copy_descriptors)(self);
    }
    pub fn copyDescriptorsSimple(self: *IDevice) noreturn {
        return (self.vtable.copy_descriptors_simple)(self);
    }
    pub fn getResourceAllocationInfo(self: *IDevice, info: *RESOURCE_ALLOCATION_INFO, visible_mask: UINT, num_descs: UINT, descs: [*]const RESOURCE_DESC) void {
        return (self.vtable.get_resource_allocation_info)(self, info, visible_mask, num_descs, descs);
    }
    pub fn getCustomHeapProperties(self: *IDevice) noreturn {
        return (self.vtable.get_custom_heap_properties)(self);
    }
    pub fn createCommittedResource(self: *IDevice) noreturn {
        return (self.vtable.create_committed_resource)(self);
    }
    pub fn createHeap(self: *IDevice, desc: *const HEAP_DESC, guid: *const GUID, heap: *?*anyopaque) HRESULT {
        return (self.vtable.create_heap)(self, desc, guid, heap);
    }
    pub fn createPlacedResource(self: *IDevice, heap: *IHeap, heap_offset: UINT64, desc: *const RESOURCE_DESC, state: RESOURCE_STATES, clear_value: ?*const CLEAR_VALUE, guid: *const GUID, resource: *?*anyopaque) HRESULT {
        return (self.vtable.create_placed_resource)(self, heap, heap_offset, desc, state, clear_value, guid, resource);
    }
    pub fn createReservedResource(self: *IDevice) noreturn {
        return (self.vtable.create_reserved_resource)(self);
    }
    pub fn createSharedHandle(self: *IDevice) noreturn {
        return (self.vtable.create_shared_handle)(self);
    }
    pub fn openSharedHandle(self: *IDevice) noreturn {
        return (self.vtable.open_shared_handle)(self);
    }
    pub fn openSharedHandleByName(self: *IDevice) noreturn {
        return (self.vtable.open_shared_handle_by_name)(self);
    }
    pub fn makeResident(self: *IDevice) noreturn {
        return (self.vtable.make_resident)(self);
    }
    pub fn evict(self: *IDevice) noreturn {
        return (self.vtable.evict)(self);
    }
    pub fn createFence(self: *IDevice, initial_value: u64, flags: FENCE_FLAGS, riid: *const GUID, fence: *?*anyopaque) HRESULT {
        return (self.vtable.create_fence)(self, initial_value, flags, riid, fence);
    }
    pub fn getDeviceRemovedReason(self: *IDevice) noreturn {
        return (self.vtable.get_device_removed_reason)(self);
    }
    pub fn getCopyableFootprints(self: *IDevice) noreturn {
        return (self.vtable.get_copyable_footprints)(self);
    }
    pub fn createQueryHeap(self: *IDevice) noreturn {
        return (self.vtable.create_query_heap)(self);
    }
    pub fn setStablePowerState(self: *IDevice) noreturn {
        return (self.vtable.set_stable_power_state)(self);
    }
    pub fn createCommandSignature(self: *IDevice, desc: *const COMMAND_SIGNATURE_DESC, root_signature: ?*IRootSignature, riid: *const GUID, signature: ?*?*anyopaque) HRESULT {
        return (self.vtable.create_command_signature)(self, desc, root_signature, riid, signature);
    }
    pub fn getResourceTiling(self: *IDevice) noreturn {
        return (self.vtable.get_resource_tiling)(self);
    }
    pub fn getAdapterLuid(self: *IDevice) noreturn {
        return (self.vtable.get_adapter_luid)(self);
    }
    // IObject methods
    pub fn getPrivateData(self: *IDevice) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IDevice) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IDevice) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IDevice) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IDevice, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IDevice) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IDevice) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const ICommandQueue = extern struct {
    pub const IID = GUID.parse("{0EC870A6-5D7E-4C22-8CFC-5BAAE07616ED}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
        update_tile_mappings: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        copy_tile_mappings: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        execute_command_lists: *const fn (*ICommandQueue, num: UINT, cmdlists: [*]const *ICommandList) callconv(.winapi) void,
        set_marker: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        begin_event: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        end_event: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        signal: *const fn (*ICommandQueue, fence: *IFence, value: u64) callconv(.winapi) HRESULT,
        wait: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        get_timestamp_frequency: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        get_clock_calibration: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
        get_desc: *const fn (*ICommandQueue) callconv(.winapi) noreturn,
    };

    pub fn updateTileMappings(self: *ICommandQueue) noreturn {
        return (self.vtable.update_tile_mappings)(self);
    }
    pub fn copyTileMappings(self: *ICommandQueue) noreturn {
        return (self.vtable.copy_tile_mappings)(self);
    }
    pub fn executeCommandLists(self: *ICommandQueue, num: UINT, cmdlists: [*]const *ICommandList) void {
        return (self.vtable.execute_command_lists)(self, num, cmdlists);
    }
    pub fn setMarker(self: *ICommandQueue) noreturn {
        return (self.vtable.set_marker)(self);
    }
    pub fn beginEvent(self: *ICommandQueue) noreturn {
        return (self.vtable.begin_event)(self);
    }
    pub fn endEvent(self: *ICommandQueue) noreturn {
        return (self.vtable.end_event)(self);
    }
    pub fn signal(self: *ICommandQueue, fence: *IFence, value: u64) HRESULT {
        return (self.vtable.signal)(self, fence, value);
    }
    pub fn wait(self: *ICommandQueue) noreturn {
        return (self.vtable.wait)(self);
    }
    pub fn getTimestampFrequency(self: *ICommandQueue) noreturn {
        return (self.vtable.get_timestamp_frequency)(self);
    }
    pub fn getClockCalibration(self: *ICommandQueue) noreturn {
        return (self.vtable.get_clock_calibration)(self);
    }
    pub fn getDesc(self: *ICommandQueue) noreturn {
        return (self.vtable.get_desc)(self);
    }
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *ICommandQueue, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *ICommandQueue) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *ICommandQueue) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *ICommandQueue) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *ICommandQueue) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *ICommandQueue, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *ICommandQueue) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *ICommandQueue) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const ICommandSignature = extern struct {
    pub const IID = GUID.parse("{C36A797C-EC80-4F0A-8985-A7B2475082D1}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
    };
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *ICommandSignature, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *ICommandSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *ICommandSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *ICommandSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *ICommandSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *ICommandSignature, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *ICommandSignature) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *ICommandSignature) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IRootSignature = extern struct {
    pub const IID = GUID.parse("{C54A6B66-72DF-4EE8-8BE5-A946A1429214}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IDeviceChild.VTable,
    };
    // IDeviceChild methods
    pub fn getDevice(self: *IRootSignature, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IRootSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IRootSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IRootSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IRootSignature) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IRootSignature, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IRootSignature) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IRootSignature) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IResource = extern struct {
    pub const IID = GUID.parse("{696442BE-A72E-4059-BC79-5B5C98040FAD}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
        map: *const fn (*IResource, subresource: UINT, read_range: ?*const RANGE, data: *?*anyopaque) callconv(.winapi) HRESULT,
        unmap: *const fn (*IResource, subresource: UINT, read_range: ?*const RANGE) callconv(.winapi) void,
        get_desc: *const fn (*IResource, desc: *RESOURCE_DESC) callconv(.winapi) HRESULT,
        get_gpu_virtual_address: *const fn (*IResource) callconv(.winapi) GPU_VIRTUAL_ADDRESS,
        write_to_subresource: *const fn (*IResource, dst_subresource: UINT, dst_box: ?*const BOX, src_data: *const anyopaque, src_row_pitch: UINT, src_depth_pitch: UINT) callconv(.winapi) HRESULT,
        read_from_subresource: *const fn (*IResource, dst_data: *anyopaque, dst_row_pitch: UINT, dst_depth_pitch: UINT, src_subresource: UINT, src_box: ?*const BOX) callconv(.winapi) HRESULT,
        get_heap_properties: *const fn (*IResource, properties: ?*HEAP_PROPERTIES, flags: ?*HEAP_FLAGS) callconv(.winapi) HRESULT,
    };

    pub fn map(self: *IResource, subresource: UINT, read_range: ?*const RANGE, data: *?*anyopaque) HRESULT {
        return (self.vtable.map)(self, subresource, read_range, data);
    }
    pub fn unmap(self: *IResource, subresource: UINT, read_range: ?*const RANGE) void {
        return (self.vtable.unmap)(self, subresource, read_range);
    }
    pub fn getDesc(self: *IResource, desc: *RESOURCE_DESC) HRESULT {
        return (self.vtable.get_desc)(self, desc);
    }
    pub fn getGpuVirtualAddress(self: *IResource) GPU_VIRTUAL_ADDRESS {
        return (self.vtable.get_gpu_virtual_address)(self);
    }
    pub fn writeToSubresource(self: *IResource, dst_subresource: UINT, dst_box: ?*const BOX, src_data: *const anyopaque, src_row_pitch: UINT, src_depth_pitch: UINT) HRESULT {
        return (self.vtable.write_to_subresource)(self, dst_subresource, dst_box, src_data, src_row_pitch, src_depth_pitch);
    }
    pub fn readFromSubresource(self: *IResource, dst_data: *anyopaque, dst_row_pitch: UINT, dst_depth_pitch: UINT, src_subresource: UINT, src_box: ?*const BOX) HRESULT {
        return (self.vtable.read_from_subresource)(self, dst_data, dst_row_pitch, dst_depth_pitch, src_subresource, src_box);
    }
    pub fn getHeapProperties(self: *IResource, properties: ?*HEAP_PROPERTIES, flags: ?*HEAP_FLAGS) HRESULT {
        return (self.vtable.get_heap_properties)(self, properties, flags);
    }
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *IResource, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IResource) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IResource) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IResource) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IResource) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IResource, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IResource) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IResource) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const ICommandAllocator = extern struct {
    pub const IID = GUID.parse("{6102DEE4-AF59-4B09-B999-B44D73F09B24}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
        reset: *const fn (*ICommandAllocator) callconv(.winapi) HRESULT,
    };

    pub fn reset(self: *ICommandAllocator) HRESULT {
        return (self.vtable.reset)(self);
    }
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *ICommandAllocator, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *ICommandAllocator) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *ICommandAllocator) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *ICommandAllocator) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *ICommandAllocator) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *ICommandAllocator, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *ICommandAllocator) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *ICommandAllocator) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const ICommandList = extern struct {
    pub const IID = GUID.parse("{7116D91C-E7E4-47CE-B8C6-EC8168F437E5}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IDeviceChild.VTable,
        get_type: *const fn (*ICommandList) callconv(.winapi) HRESULT,
    };

    pub fn getType(self: *ICommandList) HRESULT {
        return (self.vtable.get_type)(self);
    }
    // IDeviceChild methods
    pub fn getDevice(self: *ICommandList, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *ICommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *ICommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *ICommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *ICommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *ICommandList, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *ICommandList) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *ICommandList) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IGraphicsCommandList = extern struct {
    pub const IID = GUID.parse("{5B160D0F-AC1B-4185-8BA8-B3AE42A5A455}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: ICommandList.VTable,
        close: *const fn (*IGraphicsCommandList) callconv(.winapi) HRESULT,
        reset: *const fn (*IGraphicsCommandList, allocator: *ICommandAllocator, initial_state: ?*IPipelineState) callconv(.winapi) HRESULT,
        clear_state: *const fn (*IGraphicsCommandList, state: ?*IPipelineState) callconv(.winapi) void,
        draw_instanced: *const fn (*IGraphicsCommandList, vertex_count_per_instance: UINT, instance_count: UINT, start_vertex_location: UINT, start_index_location: UINT) callconv(.winapi) void,
        draw_indexed_instanced: *const fn (*IGraphicsCommandList, index_count_per_instance: UINT, instance_count: UINT, start_index_location: UINT, base_vertex_location: INT, start_instance_location: UINT) callconv(.winapi) void,
        dispatch: *const fn (*IGraphicsCommandList, x: UINT, y: UINT, z: UINT) callconv(.winapi) void,
        copy_buffer_region: *const fn (*IGraphicsCommandList, dst_buffer: *IResource, dst_offset: UINT64, src_buffer: *IResource, src_offset: UINT64, num_bytes: UINT64) callconv(.winapi) void,
        copy_texture_region: *const fn (*IGraphicsCommandList, dst: *const TEXTURE_COPY_LOCATION, dst_x: UINT, dst_y: UINT, dst_z: UINT, src: *const TEXTURE_COPY_LOCATION, src_box: ?*const BOX) callconv(.winapi) void,
        copy_resource: *const fn (*IGraphicsCommandList, dst: *IResource, src: *IResource) callconv(.winapi) void,
        copy_tiles: *const fn (*IGraphicsCommandList, tiled_resource: *IResource, tile_region_start_coordinate: *const TILED_RESOURCE_COORDINATE, tile_region_size: *const TILE_REGION_SIZE, buffer: *IResource, buffer_start_offset_in_bytes: UINT64, flags: TILE_COPY_FLAGS) callconv(.winapi) void,
        resolve_subresource: *const fn (*IGraphicsCommandList, dst_resource: *IResource, dst_subresource: UINT, src_resource: *IResource, src_subresource: UINT, format: dxgi.FORMAT) callconv(.winapi) void,
        ia_set_primitive_topology: *const fn (*IGraphicsCommandList, topology: PRIMITIVE_TOPOLOGY) callconv(.winapi) void,
        rs_set_viewports: *const fn (*IGraphicsCommandList, num: UINT, viewports: [*]const VIEWPORT) callconv(.winapi) void,
        rs_set_scissor_rects: *const fn (*IGraphicsCommandList, num: UINT, rects: [*]const RECT) callconv(.winapi) void,
        om_set_blend_factor: *const fn (*IGraphicsCommandList, blend_factor: *const [4]FLOAT) callconv(.winapi) void,
        om_set_stencil_ref: *const fn (*IGraphicsCommandList, stencil_ref: UINT) callconv(.winapi) void,
        set_pipeline_state: *const fn (*IGraphicsCommandList, pso: *IPipelineState) callconv(.winapi) void,
        resource_barrier: *const fn (*IGraphicsCommandList, num: UINT, barriers: [*]const RESOURCE_BARRIER) callconv(.winapi) void,
        execute_bundle: *const fn (*IGraphicsCommandList, cmdlist: *IGraphicsCommandList) callconv(.winapi) void,
        set_descriptor_heaps: *const fn (*IGraphicsCommandList, num: UINT, heaps: [*]const *IDescriptorHeap) callconv(.winapi) void,
        set_compute_root_signature: *const fn (*IGraphicsCommandList, root_signature: ?*IRootSignature) callconv(.winapi) void,
        set_graphics_root_signature: *const fn (*IGraphicsCommandList, root_signature: ?*IRootSignature) callconv(.winapi) void,
        set_compute_root_descriptor_table: *const fn (*IGraphicsCommandList, root_index: UINT, base_descriptor: GPU_DESCRIPTOR_HANDLE) callconv(.winapi) void,
        set_graphics_root_descriptor_table: *const fn (*IGraphicsCommandList, root_index: UINT, base_descriptor: GPU_DESCRIPTOR_HANDLE) callconv(.winapi) void,
        set_compute_root32_bit_constant: *const fn (*IGraphicsCommandList, index: UINT, data: UINT, offset: UINT) callconv(.winapi) void,
        set_graphics_root32_bit_constant: *const fn (*IGraphicsCommandList, index: UINT, data: UINT, offset: UINT) callconv(.winapi) void,
        set_compute_root32_bit_constants: *const fn (*IGraphicsCommandList, root_index: UINT, num: UINT, data: *const anyopaque, offset: UINT) callconv(.winapi) void,
        set_graphics_root32_bit_constants: *const fn (*IGraphicsCommandList, root_index: UINT, num: UINT, data: *const anyopaque, offset: UINT) callconv(.winapi) void,
        set_compute_root_constant_buffer_view: *const fn (*IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) callconv(.winapi) void,
        set_graphics_root_constant_buffer_view: *const fn (*IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) callconv(.winapi) void,
        set_compute_root_shader_resource_view: *const fn (*IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) callconv(.winapi) void,
        set_graphics_root_shader_resource_view: *const fn (*IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) callconv(.winapi) void,
        set_compute_root_unordered_access_view: *const fn (*IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) callconv(.winapi) void,
        set_graphics_root_unordered_access_view: *const fn (*IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) callconv(.winapi) void,
        ia_set_index_buffer: *const fn (*IGraphicsCommandList, view: ?*const INDEX_BUFFER_VIEW) callconv(.winapi) void,
        ia_set_vertex_buffers: *const fn (*IGraphicsCommandList, start_slot: UINT, num_views: UINT, views: ?[*]const VERTEX_BUFFER_VIEW) callconv(.winapi) void,
        so_set_targets: *const fn (*IGraphicsCommandList, start_slote: UINT, num_views: UINT, views: ?[*]const STREAM_OUTPUT_BUFFER_VIEW) callconv(.winapi) void,
        om_set_render_targets: *const fn (*IGraphicsCommandList, num_rt_descriptors: UINT, rt_descriptors: ?[*]const CPU_DESCRIPTOR_HANDLE, single_handle: BOOL, ds_descriptors: ?*const CPU_DESCRIPTOR_HANDLE) callconv(.winapi) void,
        clear_depth_stencil_view: *const fn (*IGraphicsCommandList, ds_view: CPU_DESCRIPTOR_HANDLE, clear_flags: CLEAR_FLAGS, depth: FLOAT, stencil: UINT8, num_rects: UINT, rects: ?[*]const RECT) callconv(.winapi) void,
        clear_render_target_view: *const fn (*IGraphicsCommandList, rt_view: CPU_DESCRIPTOR_HANDLE, rgba: *const [4]FLOAT, num_rects: UINT, rects: ?[*]const RECT) callconv(.winapi) void,
        clear_unordered_access_view_uint: *const fn (*IGraphicsCommandList, gpu_view: GPU_DESCRIPTOR_HANDLE, cpu_view: CPU_DESCRIPTOR_HANDLE, resource: *IResource, values: *const [4]UINT, num_rects: UINT, rects: ?[*]const RECT) callconv(.winapi) void,
        clear_unordered_access_view_float: *const fn (*IGraphicsCommandList, gpu_view: GPU_DESCRIPTOR_HANDLE, cpu_view: CPU_DESCRIPTOR_HANDLE, resource: *IResource, values: *const [4]FLOAT, num_rects: UINT, rects: ?[*]const RECT) callconv(.winapi) void,
        discard_resource: *const fn (*IGraphicsCommandList, resource: *IResource, region: ?*const DISCARD_REGION) callconv(.winapi) void,
        begin_query: *const fn (*IGraphicsCommandList, query: *IQueryHeap, query_type: QUERY_TYPE, index: UINT) callconv(.winapi) void,
        end_query: *const fn (*IGraphicsCommandList, query: *IQueryHeap, query_type: QUERY_TYPE, index: UINT) callconv(.winapi) void,
        resolve_query_data: *const fn (*IGraphicsCommandList, query: *IQueryHeap, query_type: QUERY_TYPE, start_index: UINT, num_queries: UINT, dst_resource: *IResource, buffer_offset: UINT64) callconv(.winapi) void,
        set_predication: *const fn (*IGraphicsCommandList, buffer: ?*IResource, buffer_offset: UINT64, operation: PREDICATION_OP) callconv(.winapi) void,
        set_marker: *const fn (*IGraphicsCommandList, metadata: UINT, data: ?*const anyopaque, size: UINT) callconv(.winapi) void,
        begin_event: *const fn (*IGraphicsCommandList, metadata: UINT, data: ?*const anyopaque, size: UINT) callconv(.winapi) void,
        end_event: *const fn (*IGraphicsCommandList) callconv(.winapi) void,
        execute_indirect: *const fn (*IGraphicsCommandList, command_signature: *ICommandSignature, max_commend_count: UINT, arg_buffer: *IResource, arg_buffer_offset: UINT64, count_buffer: ?*IResource, count_buffer_offset: UINT64) callconv(.winapi) void,
    };

    pub fn close(self: *IGraphicsCommandList) HRESULT {
        return (self.vtable.close)(self);
    }
    pub fn reset(self: *IGraphicsCommandList, allocator: *ICommandAllocator, initial_state: ?*IPipelineState) HRESULT {
        return (self.vtable.reset)(self, allocator, initial_state);
    }
    pub fn clearState(self: *IGraphicsCommandList, state: ?*IPipelineState) void {
        return (self.vtable.clear_state)(self, state);
    }
    pub fn drawInstanced(self: *IGraphicsCommandList, vertex_count_per_instance: UINT, instance_count: UINT, start_vertex_location: UINT, start_index_location: UINT) void {
        return (self.vtable.draw_instanced)(self, vertex_count_per_instance, instance_count, start_vertex_location, start_index_location);
    }
    pub fn drawIndexedInstanced(self: *IGraphicsCommandList, index_count_per_instance: UINT, instance_count: UINT, start_index_location: UINT, base_vertex_location: INT, start_instance_location: UINT) void {
        return (self.vtable.draw_indexed_instanced)(self, index_count_per_instance, instance_count, start_index_location, base_vertex_location, start_instance_location);
    }
    pub fn dispatch(self: *IGraphicsCommandList, x: UINT, y: UINT, z: UINT) void {
        return (self.vtable.dispatch)(self, x, y, z);
    }
    pub fn copyBufferRegion(self: *IGraphicsCommandList, dst_buffer: *IResource, dst_offset: UINT64, src_buffer: *IResource, src_offset: UINT64, num_bytes: UINT64) void {
        return (self.vtable.copy_buffer_region)(self, dst_buffer, dst_offset, src_buffer, src_offset, num_bytes);
    }
    pub fn copyTextureRegion(self: *IGraphicsCommandList, dst: *const TEXTURE_COPY_LOCATION, dst_x: UINT, dst_y: UINT, dst_z: UINT, src: *const TEXTURE_COPY_LOCATION, src_box: ?*const BOX) void {
        return (self.vtable.copy_texture_region)(self, dst, dst_x, dst_y, dst_z, src, src_box);
    }
    pub fn copyResource(self: *IGraphicsCommandList, dst: *IResource, src: *IResource) void {
        return (self.vtable.copy_resource)(self, dst, src);
    }
    pub fn copyTiles(self: *IGraphicsCommandList, tiled_resource: *IResource, tile_region_start_coordinate: *const TILED_RESOURCE_COORDINATE, tile_region_size: *const TILE_REGION_SIZE, buffer: *IResource, buffer_start_offset_in_bytes: UINT64, flags: TILE_COPY_FLAGS) void {
        return (self.vtable.copy_tiles)(self, tiled_resource, tile_region_start_coordinate, tile_region_size, buffer, buffer_start_offset_in_bytes, flags);
    }
    pub fn resolveSubresource(self: *IGraphicsCommandList, dst_resource: *IResource, dst_subresource: UINT, src_resource: *IResource, src_subresource: UINT, format: dxgi.FORMAT) void {
        return (self.vtable.resolve_subresource)(self, dst_resource, dst_subresource, src_resource, src_subresource, format);
    }
    pub fn iaSetPrimitiveTopology(self: *IGraphicsCommandList, topology: PRIMITIVE_TOPOLOGY) void {
        return (self.vtable.ia_set_primitive_topology)(self, topology);
    }
    pub fn rsSetViewports(self: *IGraphicsCommandList, num: UINT, viewports: [*]const VIEWPORT) void {
        return (self.vtable.rs_set_viewports)(self, num, viewports);
    }
    pub fn rsSetScissorRects(self: *IGraphicsCommandList, num: UINT, rects: [*]const RECT) void {
        return (self.vtable.rs_set_scissor_rects)(self, num, rects);
    }
    pub fn omSetBlendFactor(self: *IGraphicsCommandList, blend_factor: *const [4]FLOAT) void {
        return (self.vtable.om_set_blend_factor)(self, blend_factor);
    }
    pub fn omSetStencilRef(self: *IGraphicsCommandList, stencil_ref: UINT) void {
        return (self.vtable.om_set_stencil_ref)(self, stencil_ref);
    }
    pub fn setPipelineState(self: *IGraphicsCommandList, pso: *IPipelineState) void {
        return (self.vtable.set_pipeline_state)(self, pso);
    }
    pub fn resourceBarrier(self: *IGraphicsCommandList, num: UINT, barriers: [*]const RESOURCE_BARRIER) void {
        return (self.vtable.resource_barrier)(self, num, barriers);
    }
    pub fn executeBundle(self: *IGraphicsCommandList, cmdlist: *IGraphicsCommandList) void {
        return (self.vtable.execute_bundle)(self, cmdlist);
    }
    pub fn setDescriptorHeaps(self: *IGraphicsCommandList, num: UINT, heaps: [*]const *IDescriptorHeap) void {
        return (self.vtable.set_descriptor_heaps)(self, num, heaps);
    }
    pub fn setComputeRootSignature(self: *IGraphicsCommandList, root_signature: ?*IRootSignature) void {
        return (self.vtable.set_compute_root_signature)(self, root_signature);
    }
    pub fn setGraphicsRootSignature(self: *IGraphicsCommandList, root_signature: ?*IRootSignature) void {
        return (self.vtable.set_graphics_root_signature)(self, root_signature);
    }
    pub fn setComputeRootDescriptorTable(self: *IGraphicsCommandList, root_index: UINT, base_descriptor: GPU_DESCRIPTOR_HANDLE) void {
        return (self.vtable.set_compute_root_descriptor_table)(self, root_index, base_descriptor);
    }
    pub fn setGraphicsRootDescriptorTable(self: *IGraphicsCommandList, root_index: UINT, base_descriptor: GPU_DESCRIPTOR_HANDLE) void {
        return (self.vtable.set_graphics_root_descriptor_table)(self, root_index, base_descriptor);
    }
    pub fn setComputeRoot32BitConstant(self: *IGraphicsCommandList, index: UINT, data: UINT, offset: UINT) void {
        return (self.vtable.set_compute_root32_bit_constant)(self, index, data, offset);
    }
    pub fn setGraphicsRoot32BitConstant(self: *IGraphicsCommandList, index: UINT, data: UINT, offset: UINT) void {
        return (self.vtable.set_graphics_root32_bit_constant)(self, index, data, offset);
    }
    pub fn setComputeRoot32BitConstants(self: *IGraphicsCommandList, root_index: UINT, num: UINT, data: *const anyopaque, offset: UINT) void {
        return (self.vtable.set_compute_root32_bit_constants)(self, root_index, num, data, offset);
    }
    pub fn setGraphicsRoot32BitConstants(self: *IGraphicsCommandList, root_index: UINT, num: UINT, data: *const anyopaque, offset: UINT) void {
        return (self.vtable.set_graphics_root32_bit_constants)(self, root_index, num, data, offset);
    }
    pub fn setComputeRootConstantBufferView(self: *IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) void {
        return (self.vtable.set_compute_root_constant_buffer_view)(self, index, buffer_location);
    }
    pub fn setGraphicsRootConstantBufferView(self: *IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) void {
        return (self.vtable.set_graphics_root_constant_buffer_view)(self, index, buffer_location);
    }
    pub fn setComputeRootShaderResourceView(self: *IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) void {
        return (self.vtable.set_compute_root_shader_resource_view)(self, index, buffer_location);
    }
    pub fn setGraphicsRootShaderResourceView(self: *IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) void {
        return (self.vtable.set_graphics_root_shader_resource_view)(self, index, buffer_location);
    }
    pub fn setComputeRootUnorderedAccessView(self: *IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) void {
        return (self.vtable.set_compute_root_unordered_access_view)(self, index, buffer_location);
    }
    pub fn setGraphicsRootUnorderedAccessView(self: *IGraphicsCommandList, index: UINT, buffer_location: GPU_VIRTUAL_ADDRESS) void {
        return (self.vtable.set_graphics_root_unordered_access_view)(self, index, buffer_location);
    }
    pub fn iaSetIndexBuffer(self: *IGraphicsCommandList, view: ?*const INDEX_BUFFER_VIEW) void {
        return (self.vtable.ia_set_index_buffer)(self, view);
    }
    pub fn iaSetVertexBuffers(self: *IGraphicsCommandList, start_slot: UINT, num_views: UINT, views: ?[*]const VERTEX_BUFFER_VIEW) void {
        return (self.vtable.ia_set_vertex_buffers)(self, start_slot, num_views, views);
    }
    pub fn soSetTargets(self: *IGraphicsCommandList, start_slote: UINT, num_views: UINT, views: ?[*]const STREAM_OUTPUT_BUFFER_VIEW) void {
        return (self.vtable.so_set_targets)(self, start_slote, num_views, views);
    }
    pub fn omSetRenderTargets(self: *IGraphicsCommandList, num_rt_descriptors: UINT, rt_descriptors: ?[*]const CPU_DESCRIPTOR_HANDLE, single_handle: BOOL, ds_descriptors: ?*const CPU_DESCRIPTOR_HANDLE) void {
        return (self.vtable.om_set_render_targets)(self, num_rt_descriptors, rt_descriptors, single_handle, ds_descriptors);
    }
    pub fn clearDepthStencilView(self: *IGraphicsCommandList, ds_view: CPU_DESCRIPTOR_HANDLE, clear_flags: CLEAR_FLAGS, depth: FLOAT, stencil: UINT8, num_rects: UINT, rects: ?[*]const RECT) void {
        return (self.vtable.clear_depth_stencil_view)(self, ds_view, clear_flags, depth, stencil, num_rects, rects);
    }
    pub fn clearRenderTargetView(self: *IGraphicsCommandList, rt_view: CPU_DESCRIPTOR_HANDLE, rgba: *const [4]FLOAT, num_rects: UINT, rects: ?[*]const RECT) void {
        return (self.vtable.clear_render_target_view)(self, rt_view, rgba, num_rects, rects);
    }
    pub fn clearUnorderedAccessViewUint(self: *IGraphicsCommandList, gpu_view: GPU_DESCRIPTOR_HANDLE, cpu_view: CPU_DESCRIPTOR_HANDLE, resource: *IResource, values: *const [4]UINT, num_rects: UINT, rects: ?[*]const RECT) void {
        return (self.vtable.clear_unordered_access_view_uint)(self, gpu_view, cpu_view, resource, values, num_rects, rects);
    }
    pub fn clearUnorderedAccessViewFloat(self: *IGraphicsCommandList, gpu_view: GPU_DESCRIPTOR_HANDLE, cpu_view: CPU_DESCRIPTOR_HANDLE, resource: *IResource, values: *const [4]FLOAT, num_rects: UINT, rects: ?[*]const RECT) void {
        return (self.vtable.clear_unordered_access_view_float)(self, gpu_view, cpu_view, resource, values, num_rects, rects);
    }
    pub fn discardResource(self: *IGraphicsCommandList, resource: *IResource, region: ?*const DISCARD_REGION) void {
        return (self.vtable.discard_resource)(self, resource, region);
    }
    pub fn beginQuery(self: *IGraphicsCommandList, query: *IQueryHeap, query_type: QUERY_TYPE, index: UINT) void {
        return (self.vtable.begin_query)(self, query, query_type, index);
    }
    pub fn endQuery(self: *IGraphicsCommandList, query: *IQueryHeap, query_type: QUERY_TYPE, index: UINT) void {
        return (self.vtable.end_query)(self, query, query_type, index);
    }
    pub fn resolveQueryData(self: *IGraphicsCommandList, query: *IQueryHeap, query_type: QUERY_TYPE, start_index: UINT, num_queries: UINT, dst_resource: *IResource, buffer_offset: UINT64) void {
        return (self.vtable.resolve_query_data)(self, query, query_type, start_index, num_queries, dst_resource, buffer_offset);
    }
    pub fn setPredication(self: *IGraphicsCommandList, buffer: ?*IResource, buffer_offset: UINT64, operation: PREDICATION_OP) void {
        return (self.vtable.set_predication)(self, buffer, buffer_offset, operation);
    }
    pub fn setMarker(self: *IGraphicsCommandList, metadata: UINT, data: ?*const anyopaque, size: UINT) void {
        return (self.vtable.set_marker)(self, metadata, data, size);
    }
    pub fn beginEvent(self: *IGraphicsCommandList, metadata: UINT, data: ?*const anyopaque, size: UINT) void {
        return (self.vtable.begin_event)(self, metadata, data, size);
    }
    pub fn endEvent(self: *IGraphicsCommandList) void {
        return (self.vtable.end_event)(self);
    }
    pub fn executeIndirect(self: *IGraphicsCommandList, command_signature: *ICommandSignature, max_commend_count: UINT, arg_buffer: *IResource, arg_buffer_offset: UINT64, count_buffer: ?*IResource, count_buffer_offset: UINT64) void {
        return (self.vtable.execute_indirect)(self, command_signature, max_commend_count, arg_buffer, arg_buffer_offset, count_buffer, count_buffer_offset);
    }
    // ICommandList methods
    pub fn getType(self: *IGraphicsCommandList) HRESULT {
        return (@as(*const ICommandList.VTable, @ptrCast(self.vtable)).get_type)(@ptrCast(self));
    }
    // IDeviceChild methods
    pub fn getDevice(self: *IGraphicsCommandList, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IGraphicsCommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IGraphicsCommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IGraphicsCommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IGraphicsCommandList) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IGraphicsCommandList, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IGraphicsCommandList) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IGraphicsCommandList) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IPipelineState = extern struct {
    pub const IID = GUID.parse("{765A30F3-F624-4C6F-A828-ACE948622445}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
        get_cached_blob: *const fn (*IPipelineState, blob: **IBlob) callconv(.winapi) HRESULT,
    };

    pub fn getCachedBlob(self: *IPipelineState, blob: **IBlob) HRESULT {
        return (self.vtable.get_cached_blob)(self, blob);
    }
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *IPipelineState, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IPipelineState) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IPipelineState) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IPipelineState) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IPipelineState) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IPipelineState, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IPipelineState) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IPipelineState) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IDescriptorHeap = extern struct {
    pub const IID = GUID.parse("{8EFB471D-616C-4F49-90F7-127BB763FA51}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
        get_desc: *const fn (*IDescriptorHeap, desc: *DESCRIPTOR_HEAP_DESC) callconv(.winapi) HRESULT,
        get_cpu_descriptor_handle_for_heap_start: *const fn (*IDescriptorHeap, handle: *CPU_DESCRIPTOR_HANDLE) callconv(.winapi) HRESULT,
        get_gpu_descriptor_handle_for_heap_start: *const fn (*IDescriptorHeap, handle: *GPU_DESCRIPTOR_HANDLE) callconv(.winapi) HRESULT,
    };

    pub fn getDesc(self: *IDescriptorHeap, desc: *DESCRIPTOR_HEAP_DESC) HRESULT {
        return (self.vtable.get_desc)(self, desc);
    }
    pub fn getCpuDescriptorHandleForHeapStart(self: *IDescriptorHeap, handle: *CPU_DESCRIPTOR_HANDLE) HRESULT {
        return (self.vtable.get_cpu_descriptor_handle_for_heap_start)(self, handle);
    }
    pub fn getGpuDescriptorHandleForHeapStart(self: *IDescriptorHeap, handle: *GPU_DESCRIPTOR_HANDLE) HRESULT {
        return (self.vtable.get_gpu_descriptor_handle_for_heap_start)(self, handle);
    }
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *IDescriptorHeap, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IDescriptorHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IDescriptorHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IDescriptorHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IDescriptorHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IDescriptorHeap, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IDescriptorHeap) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IDescriptorHeap) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IQueryHeap = extern struct {
    pub const IID = GUID.parse("{0D9658AE-ED45-469E-A61D-970EC583CAB4}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
    };
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *IQueryHeap, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IQueryHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IQueryHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IQueryHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IQueryHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IQueryHeap, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IQueryHeap) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IQueryHeap) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IFence = extern struct {
    pub const IID = GUID.parse("{0A753DCF-C4D8-4B91-ADF6-BE5A60D95A76}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
        get_completed_value: *const fn (*IFence) callconv(.winapi) u64,
        set_event_on_completion: *const fn (*IFence, value: u64, event: HANDLE) callconv(.winapi) HRESULT,
        signal: *const fn (*IFence, value: u64) callconv(.winapi) HRESULT,
    };

    pub fn getCompletedValue(self: *IFence) u64 {
        return (self.vtable.get_completed_value)(self);
    }
    pub fn setEventOnCompletion(self: *IFence, value: u64, event: HANDLE) HRESULT {
        return (self.vtable.set_event_on_completion)(self, value, event);
    }
    pub fn signal(self: *IFence, value: u64) HRESULT {
        return (self.vtable.signal)(self, value);
    }
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *IFence, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IFence) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IFence) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IFence) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IFence) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IFence, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IFence) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IFence) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};

pub const IHeap = extern struct {
    pub const IID = GUID.parse("{6B3B2502-6E51-45B3-90EE-9884265E8DF3}");

    vtable: *const VTable,

    const VTable = extern struct {
        base: IPageable.VTable,
        get_desc: *const fn (*IHeap, desc: *HEAP_DESC) callconv(.winapi) *HEAP_DESC,
    };

    pub fn getDesc(self: *IHeap, desc: *HEAP_DESC) *HEAP_DESC {
        return (self.vtable.get_desc)(self, desc);
    }
    // IPageable methods
    // IDeviceChild methods
    pub fn getDevice(self: *IHeap, riid: *const GUID, device: *?*anyopaque) HRESULT {
        return (@as(*const IDeviceChild.VTable, @ptrCast(self.vtable)).get_device)(@ptrCast(self), riid, device);
    }
    // IObject methods
    pub fn getPrivateData(self: *IHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).get_private_data)(@ptrCast(self));
    }
    pub fn setPrivateData(self: *IHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data)(@ptrCast(self));
    }
    pub fn setPrivateDataInterface(self: *IHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_private_data_interface)(@ptrCast(self));
    }
    pub fn setName(self: *IHeap) noreturn {
        return (@as(*const IObject.VTable, @ptrCast(self.vtable)).set_name)(@ptrCast(self));
    }
    // IUnknown methods
    pub fn queryInterface(self: *IHeap, riid: *const GUID, out: *?*anyopaque) HRESULT {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).query_interface)(@ptrCast(self), riid, out);
    }
    pub fn addRef(self: *IHeap) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).add_ref)(@ptrCast(self));
    }
    pub fn release(self: *IHeap) ULONG {
        return (@as(*const IUnknown.VTable, @ptrCast(self.vtable)).release)(@ptrCast(self));
    }
};
